diff --git a/.gitignore b/.gitignore
index 4e91139..ec70caa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,3 +43,7 @@ lib*.pc
 /Release/
 /tmp_install/
 /portlock/
+
+# pg_lab specifics
+dist/
+pg.log
diff --git a/configure b/configure
index 71155f4..8f2d91b 100755
--- a/configure
+++ b/configure
@@ -19371,7 +19371,7 @@ fi


 cat >>confdefs.h <<_ACEOF
-#define PG_VERSION_STR "PostgreSQL $PG_VERSION on $host, compiled by $cc_string, `expr $ac_cv_sizeof_void_p \* 8`-bit"
+#define PG_VERSION_STR "PostgreSQL $PG_VERSION with pg_lab on $host, compiled by $cc_string, `expr $ac_cv_sizeof_void_p \* 8`-bit"
 _ACEOF


diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index 6c2e5c8..0fb38f1 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -24,6 +24,9 @@
 #include "nodes/extensible.h"
 #include "nodes/makefuncs.h"
 #include "nodes/nodeFuncs.h"
+#include "optimizer/geqo.h"
+#include "optimizer/paths.h"
+#include "optimizer/planner.h"
 #include "parser/analyze.h"
 #include "parser/parsetree.h"
 #include "rewrite/rewriteHandler.h"
@@ -54,6 +57,17 @@ explain_get_index_name_hook_type explain_get_index_name_hook = NULL;
 #define X_CLOSE_IMMEDIATE 2
 #define X_NOWHITESPACE 4

+char	  **current_planner_type = &PLANNER_TYPE_UNSET;
+extern PGDLLIMPORT planner_hook_type planner_hook;
+static planner_hook_type prev_planner_hook;
+static PlannedStmt *planner_explain_interceptor(Query *parse, const char *query_string,
+												int cursorOptions, ParamListInfo boundParams);
+
+char	  **current_join_ordering_type = &PLANNER_TYPE_UNSET;
+extern PGDLLIMPORT join_search_hook_type join_search_hook;
+static join_search_hook_type prev_join_search_hook;
+static RelOptInfo *join_search_explain_interceptor(PlannerInfo *root, int levels_needed, List *initial_rels);
+
 static void ExplainOneQuery(Query *query, int cursorOptions,
 							IntoClause *into, ExplainState *es,
 							const char *queryString, ParamListInfo params,
@@ -155,6 +169,57 @@ static void ExplainYAMLLineStarting(ExplainState *es);
 static void escape_yaml(StringInfo buf, const char *str);


+char	   *PLANNER_TYPE_UNSET = "<unset>";
+char	   *PLANNER_TYPE_CUSTOM = "Custom Hook";
+char	   *PLANNER_TYPE_DEFAULT = "Standard";
+char	   *JOIN_ORDER_TYPE_CUSTOM = "Custom Hook";
+char	   *JOIN_ORDER_TYPE_GEQO = "GeQO";
+char	   *JOIN_ORDER_TYPE_STANDARD = "Dynamic Programming";
+
+PlannedStmt *
+planner_explain_interceptor(Query *parse, const char *query_string, int cursorOptions, ParamListInfo boundParams)
+{
+	PlannedStmt *result;
+
+	if (prev_planner_hook)
+	{
+		current_planner_type = &PLANNER_TYPE_CUSTOM;
+		result = (*prev_planner_hook) (parse, query_string, cursorOptions, boundParams);
+	}
+	else
+	{
+		current_planner_type = &PLANNER_TYPE_DEFAULT;
+		result = standard_planner(parse, query_string, cursorOptions, boundParams);
+	}
+
+	return result;
+}
+
+
+RelOptInfo *
+join_search_explain_interceptor(PlannerInfo *root, int levels_needed, List *initial_rels)
+{
+	RelOptInfo *result;
+
+	if (prev_join_search_hook)
+	{
+		current_join_ordering_type = &JOIN_ORDER_TYPE_CUSTOM;
+		result = (*prev_join_search_hook) (root, levels_needed, initial_rels);
+	}
+	else if (enable_geqo && levels_needed >= geqo_threshold)
+	{
+		current_join_ordering_type = &JOIN_ORDER_TYPE_GEQO;
+		result = geqo(root, levels_needed, initial_rels);
+	}
+	else
+	{
+		current_join_ordering_type = &JOIN_ORDER_TYPE_STANDARD;
+		result = standard_join_search(root, levels_needed, initial_rels);
+	}
+
+	return result;
+}
+

 /*
  * ExplainQuery -
@@ -403,7 +468,23 @@ ExplainOneQuery(Query *query, int cursorOptions,
 		INSTR_TIME_SET_CURRENT(planstart);

 		/* plan the query */
-		plan = pg_plan_query(query, queryString, cursorOptions, params);
+		prev_planner_hook = planner_hook;
+		planner_hook = planner_explain_interceptor;
+		prev_join_search_hook = join_search_hook;
+		join_search_hook = join_search_explain_interceptor;
+
+		PG_TRY();
+		{
+			plan = pg_plan_query(query, queryString, cursorOptions, params);
+		}
+		PG_FINALLY();
+		{
+			planner_hook = prev_planner_hook;
+			prev_planner_hook = NULL;
+			join_search_hook = prev_join_search_hook;
+			prev_join_search_hook = NULL;
+		}
+		PG_END_TRY();

 		INSTR_TIME_SET_CURRENT(planduration);
 		INSTR_TIME_SUBTRACT(planduration, planstart);
@@ -418,6 +499,25 @@ ExplainOneQuery(Query *query, int cursorOptions,
 		/* run it (if needed) and produce output */
 		ExplainOnePlan(plan, into, es, queryString, params, queryEnv,
 					   &planduration, (es->buffers ? &bufusage : NULL));
+
+		if (es->format == EXPLAIN_FORMAT_TEXT)
+		{
+			ExplainOpenGroup("Optimizer", "Optimizer", true, es);
+			ExplainIndentText(es);
+			appendStringInfo(es->str, "Optimizer: planner=%s", *current_planner_type);
+			appendStringInfo(es->str, " joinorder=%s", *current_join_ordering_type);
+			ExplainCloseGroup("Optimizer", "Optimizer", true, es);
+		}
+		else
+		{
+			ExplainOpenGroup("OptimizerInfo", NULL, true, es);
+			ExplainOpenGroup("Optimizer", "Optimizer", true, es);
+			ExplainPropertyText("Planner", *current_planner_type, es);
+			ExplainPropertyText("Join Ordering", *current_join_ordering_type, es);
+			ExplainCloseGroup("Optimizer", "Optimizer", true, es);
+			ExplainCloseGroup("OptimizerInfo", NULL, true, es);
+		}
+
 	}
 }

diff --git a/src/backend/main/main.c b/src/backend/main/main.c
index ed11e8b..0c44aa8 100644
--- a/src/backend/main/main.c
+++ b/src/backend/main/main.c
@@ -58,7 +58,7 @@ static void check_root(const char *progname);
 int
 main(int argc, char *argv[])
 {
-	bool		do_check_root = true;
+	bool		do_check_root = false;

 	reached_main = true;

@@ -385,6 +385,8 @@ help(const char *progname)
 static void
 check_root(const char *progname)
 {
+    return;
+
 #ifndef WIN32
 	if (geteuid() == 0)
 	{
diff --git a/src/backend/optimizer/path/costsize.c b/src/backend/optimizer/path/costsize.c
index ef475d9..c56439d 100644
--- a/src/backend/optimizer/path/costsize.c
+++ b/src/backend/optimizer/path/costsize.c
@@ -154,6 +154,30 @@ bool		enable_partition_pruning = true;
 bool		enable_presorted_aggregate = true;
 bool		enable_async_append = true;

+cost_seqscan_hook_type cost_seqscan_hook = NULL;
+cost_index_hook_type cost_index_hook = NULL;
+cost_bitmap_heap_scan_hook_type cost_bitmap_heap_scan_hook = NULL;
+cost_bitmap_and_node_hook_type cost_bitmap_and_node_hook = NULL;
+cost_bitmap_or_node_hook_type cost_bitmap_or_node_hook = NULL;
+cost_sort_hook_type cost_sort_hook = NULL;
+cost_incremental_sort_hook_type cost_incremental_sort_hook = NULL;
+cost_material_hook_type cost_material_hook = NULL;
+cost_rescan_hook_type cost_rescan_hook = NULL;
+cost_memoize_rescan_hook_type cost_memoize_rescan_hook = NULL;
+cost_agg_hook_type cost_agg_hook = NULL;
+cost_windowagg_hook_type cost_windowagg_hook = NULL;
+cost_group_hook_type cost_group_hook = NULL;
+initial_cost_nestloop_hook_type initial_cost_nestloop_hook = NULL;
+final_cost_nestloop_hook_type final_cost_nestloop_hook = NULL;
+initial_cost_mergejoin_hook_type initial_cost_mergejoin_hook = NULL;
+final_cost_mergejoin_hook_type final_cost_mergejoin_hook = NULL;
+initial_cost_hashjoin_hook_type initial_cost_hashjoin_hook = NULL;
+final_cost_hashjoin_hook_type final_cost_hashjoin_hook = NULL;
+cost_gather_hook_type cost_gather_hook = NULL;
+cost_gather_merge_hook_type cost_gather_merge_hook = NULL;
+set_baserel_size_estimates_hook_type set_baserel_size_estimates_hook = NULL;
+set_joinrel_size_estimates_hook_type set_joinrel_size_estimates_hook = NULL;
+
 typedef struct
 {
 	PlannerInfo *root;
@@ -164,8 +188,6 @@ static List *extract_nonindex_conditions(List *qual_clauses, List *indexclauses)
 static MergeScanSelCache *cached_scansel(PlannerInfo *root,
 										 RestrictInfo *rinfo,
 										 PathKey *pathkey);
-static void cost_rescan(PlannerInfo *root, Path *path,
-						Cost *rescan_startup_cost, Cost *rescan_total_cost);
 static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context);
 static void get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
 									  ParamPathInfo *param_info,
@@ -255,6 +277,26 @@ clamp_cardinality_to_long(Cardinality x)
 void
 cost_seqscan(Path *path, PlannerInfo *root,
 			 RelOptInfo *baserel, ParamPathInfo *param_info)
+{
+	if (cost_seqscan_hook)
+	{
+		(*cost_seqscan_hook) (path, root, baserel, param_info);
+	}
+	else
+	{
+		standard_cost_seqscan(path, root, baserel, param_info);
+	}
+}
+
+/*
+ * standard_cost_seqscan
+ * 	  Default cost estimation for sequential scans.
+ *
+ * See cost_seqscan for the meaning of the parameters.
+ */
+void
+standard_cost_seqscan(Path *path, PlannerInfo *root,
+					  RelOptInfo *baserel, ParamPathInfo *param_info)
 {
 	Cost		startup_cost = 0;
 	Cost		cpu_run_cost;
@@ -408,6 +450,27 @@ void
 cost_gather(GatherPath *path, PlannerInfo *root,
 			RelOptInfo *rel, ParamPathInfo *param_info,
 			double *rows)
+{
+	if (cost_gather_hook)
+	{
+		(*cost_gather_hook) (path, root, rel, param_info, rows);
+	}
+	else
+	{
+		standard_cost_gather(path, root, rel, param_info, rows);
+	}
+}
+
+/*
+ * standard_cost_gather
+ *	  Default cost estimation for Gather nodes.
+ *
+ * See cost_gather for the meaning of the parameters.
+ */
+void
+standard_cost_gather(GatherPath *path, PlannerInfo *root,
+					 RelOptInfo *rel, ParamPathInfo *param_info,
+					 double *rows)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -447,6 +510,30 @@ cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
 				  RelOptInfo *rel, ParamPathInfo *param_info,
 				  Cost input_startup_cost, Cost input_total_cost,
 				  double *rows)
+{
+	if (cost_gather_merge_hook)
+	{
+		(*cost_gather_merge_hook) (path, root, rel, param_info,
+								   input_startup_cost, input_total_cost, rows);
+	}
+	else
+	{
+		standard_cost_gather_merge(path, root, rel, param_info,
+								   input_startup_cost, input_total_cost, rows);
+	}
+}
+
+/*
+ * standard_cost_gather_merge
+ *	  Default cost estimation for Gather Merge nodes.
+ *
+ * See cost_gather_merge for the meaning of the parameters.
+ */
+void
+standard_cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
+						   RelOptInfo *rel, ParamPathInfo *param_info,
+						   Cost input_startup_cost, Cost input_total_cost,
+						   double *rows)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -520,6 +607,26 @@ cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
 void
 cost_index(IndexPath *path, PlannerInfo *root, double loop_count,
 		   bool partial_path)
+{
+	if (cost_index_hook)
+	{
+		(*cost_index_hook) (path, root, loop_count, partial_path);
+	}
+	else
+	{
+		standard_cost_index(path, root, loop_count, partial_path);
+	}
+}
+
+/*
+ * standard_cost_index
+ *	  Default cost estimation for index scans.
+ *
+ * See cost_index for the meaning of the parameters.
+ */
+void
+standard_cost_index(IndexPath *path, PlannerInfo *root, double loop_count,
+					bool partial_path)
 {
 	IndexOptInfo *index = path->indexinfo;
 	RelOptInfo *baserel = index->rel;
@@ -985,6 +1092,29 @@ void
 cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 					  ParamPathInfo *param_info,
 					  Path *bitmapqual, double loop_count)
+{
+	if (cost_bitmap_heap_scan_hook)
+	{
+		(*cost_bitmap_heap_scan_hook) (path, root, baserel, param_info,
+									   bitmapqual, loop_count);
+	}
+	else
+	{
+		standard_cost_bitmap_heap_scan(path, root, baserel, param_info,
+									   bitmapqual, loop_count);
+	}
+}
+
+/*
+ * standard_cost_bitmap_heap_scan
+ * 		Default cost estimation for bitmap heap scans.
+ *
+ * See cost_bitmap_heap_scan for the meaning of the parameters.
+ */
+void
+standard_cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+							   ParamPathInfo *param_info,
+							   Path *bitmapqual, double loop_count)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -1127,6 +1257,25 @@ cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
  */
 void
 cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
+{
+	if (cost_bitmap_and_node_hook)
+	{
+		(*cost_bitmap_and_node_hook) (path, root);
+	}
+	else
+	{
+		standard_cost_bitmap_and_node(path, root);
+	}
+}
+
+/*
+ * standard_cost_bitmap_and_node
+ *	  Default cost estimation for BitmapAnd nodes.
+ *
+ * See cost_bitmap_and_node for the meaning of the parameters.
+ */
+void
+standard_cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
 {
 	Cost		totalCost;
 	Selectivity selec;
@@ -1171,6 +1320,25 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
  */
 void
 cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
+{
+	if (cost_bitmap_or_node_hook)
+	{
+		(*cost_bitmap_or_node_hook) (path, root);
+	}
+	else
+	{
+		standard_cost_bitmap_or_node(path, root);
+	}
+}
+
+/*
+ * standard_cost_bitmap_or_node
+ *	  Default cost estimation for BitmapOr nodes.
+ *
+ * See cost_bitmap_or_node for the meaning of the parameters.
+ */
+void
+standard_cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
 {
 	Cost		totalCost;
 	Selectivity selec;
@@ -1960,6 +2128,36 @@ cost_incremental_sort(Path *path,
 					  Cost input_startup_cost, Cost input_total_cost,
 					  double input_tuples, int width, Cost comparison_cost, int sort_mem,
 					  double limit_tuples)
+
+{
+	if (cost_incremental_sort_hook)
+	{
+		(*cost_incremental_sort_hook) (path, root, pathkeys, presorted_keys,
+									   input_startup_cost, input_total_cost,
+									   input_tuples, width, comparison_cost,
+									   sort_mem, limit_tuples);
+	}
+	else
+	{
+		standard_cost_incremental_sort(path, root, pathkeys, presorted_keys,
+									   input_startup_cost, input_total_cost,
+									   input_tuples, width, comparison_cost,
+									   sort_mem, limit_tuples);
+	}
+}
+
+/*
+ * standard_cost_incremental_sort
+ * 		Default estimation for incremental sort.
+ *
+ * See cost_incremental_sort for the meaning of the parameters.
+ */
+void
+standard_cost_incremental_sort(Path *path,
+							   PlannerInfo *root, List *pathkeys, int presorted_keys,
+							   Cost input_startup_cost, Cost input_total_cost,
+							   double input_tuples, int width, Cost comparison_cost, int sort_mem,
+							   double limit_tuples)
 {
 	Cost		startup_cost,
 				run_cost,
@@ -2097,6 +2295,30 @@ cost_sort(Path *path, PlannerInfo *root,
 		  List *pathkeys, Cost input_cost, double tuples, int width,
 		  Cost comparison_cost, int sort_mem,
 		  double limit_tuples)
+{
+	if (cost_sort_hook)
+	{
+		(*cost_sort_hook) (path, root, pathkeys, input_cost, tuples, width,
+						   comparison_cost, sort_mem, limit_tuples);
+	}
+	else
+	{
+		standard_cost_sort(path, root, pathkeys, input_cost, tuples, width,
+						   comparison_cost, sort_mem, limit_tuples);
+	}
+}
+
+/*
+ * standard_cost_sort
+ * 		Default estimation for sort.
+ *
+ * See cost_sort for the meaning of the parameters.
+ */
+void
+standard_cost_sort(Path *path, PlannerInfo *root,
+				   List *pathkeys, Cost input_cost, double tuples, int width,
+				   Cost comparison_cost, int sort_mem,
+				   double limit_tuples)

 {
 	Cost		startup_cost;
@@ -2425,6 +2647,28 @@ void
 cost_material(Path *path,
 			  Cost input_startup_cost, Cost input_total_cost,
 			  double tuples, int width)
+{
+	if (cost_material_hook)
+	{
+		(*cost_material_hook) (path, input_startup_cost, input_total_cost,
+							   tuples, width);
+	}
+	else
+	{
+		standard_cost_material(path, input_startup_cost, input_total_cost,
+							   tuples, width);
+	}
+}
+
+/*
+ * standard_cost_material
+ *	  Default cost estimation for materialization.
+ * See cost_material for the meaning of the parameters.
+ */
+void
+standard_cost_material(Path *path,
+					   Cost input_startup_cost, Cost input_total_cost,
+					   double tuples, int width)
 {
 	Cost		startup_cost = input_startup_cost;
 	Cost		run_cost = input_total_cost - input_startup_cost;
@@ -2477,9 +2721,31 @@ cost_material(Path *path,
  * never see any parameter value twice, in which case we'd never get a cache
  * hit and caching would be a complete waste of effort.
  */
-static void
+void
 cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
 					Cost *rescan_startup_cost, Cost *rescan_total_cost)
+{
+	if (cost_memoize_rescan_hook)
+	{
+		(*cost_memoize_rescan_hook) (root, mpath,
+									 rescan_startup_cost, rescan_total_cost);
+	}
+	else
+	{
+		standard_cost_memoize_rescan(root, mpath,
+									 rescan_startup_cost, rescan_total_cost);
+	}
+}
+
+/*
+ * standard_cost_memoize_rescan
+ *	  Default cost estimation a Memoize node.
+ *
+ * See cost_memoize_rescan for the meaning of the parameters.
+ */
+void
+standard_cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
+							 Cost *rescan_startup_cost, Cost *rescan_total_cost)
 {
 	EstimationInfo estinfo;
 	ListCell   *lc;
@@ -2625,6 +2891,39 @@ cost_agg(Path *path, PlannerInfo *root,
 		 List *quals,
 		 Cost input_startup_cost, Cost input_total_cost,
 		 double input_tuples, double input_width)
+{
+	if (cost_agg_hook)
+	{
+		(*cost_agg_hook) (path, root,
+						  aggstrategy, aggcosts,
+						  numGroupCols, numGroups,
+						  quals,
+						  input_startup_cost, input_total_cost,
+						  input_tuples, input_width);
+	}
+	else
+	{
+		standard_cost_agg(path, root,
+						  aggstrategy, aggcosts,
+						  numGroupCols, numGroups,
+						  quals,
+						  input_startup_cost, input_total_cost,
+						  input_tuples, input_width);
+	}
+}
+
+/*
+ * standard_cost_agg
+ *		Default cost estimation for Aggregation nodes.
+ * See cost_agg for the meaning of the parameters.
+ */
+void
+standard_cost_agg(Path *path, PlannerInfo *root,
+				  AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
+				  int numGroupCols, double numGroups,
+				  List *quals,
+				  Cost input_startup_cost, Cost input_total_cost,
+				  double input_tuples, double input_width)
 {
 	double		output_tuples;
 	Cost		startup_cost;
@@ -2821,6 +3120,34 @@ cost_windowagg(Path *path, PlannerInfo *root,
 			   List *windowFuncs, int numPartCols, int numOrderCols,
 			   Cost input_startup_cost, Cost input_total_cost,
 			   double input_tuples)
+{
+	if (cost_windowagg_hook)
+	{
+		(*cost_windowagg_hook) (path, root,
+								windowFuncs, numPartCols, numOrderCols,
+								input_startup_cost, input_total_cost,
+								input_tuples);
+	}
+	else
+	{
+		standard_cost_windowagg(path, root,
+								windowFuncs, numPartCols, numOrderCols,
+								input_startup_cost, input_total_cost,
+								input_tuples);
+	}
+}
+
+/*
+ * standard_cost_windowagg
+ *		Default cost estimation for WindowAgg nodes.
+ *
+ * See cost_windowagg for the meaning of the parameters.
+ */
+void
+standard_cost_windowagg(Path *path, PlannerInfo *root,
+						List *windowFuncs, int numPartCols, int numOrderCols,
+						Cost input_startup_cost, Cost input_total_cost,
+						double input_tuples)
 {
 	Cost		startup_cost;
 	Cost		total_cost;
@@ -2896,6 +3223,37 @@ cost_group(Path *path, PlannerInfo *root,
 		   List *quals,
 		   Cost input_startup_cost, Cost input_total_cost,
 		   double input_tuples)
+{
+	if (cost_group_hook)
+	{
+		(*cost_group_hook) (path, root,
+							numGroupCols, numGroups,
+							quals,
+							input_startup_cost, input_total_cost,
+							input_tuples);
+	}
+	else
+	{
+		standard_cost_group(path, root,
+							numGroupCols, numGroups,
+							quals,
+							input_startup_cost, input_total_cost,
+							input_tuples);
+	}
+}
+
+/*
+ * standard_cost_group
+ *		Default cost estimation for Group nodes.
+ *
+ * See cost_group for the meaning of the parameters.
+ */
+void
+standard_cost_group(Path *path, PlannerInfo *root,
+					int numGroupCols, double numGroups,
+					List *quals,
+					Cost input_startup_cost, Cost input_total_cost,
+					double input_tuples)
 {
 	double		output_tuples;
 	Cost		startup_cost;
@@ -2965,6 +3323,34 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 					  JoinType jointype,
 					  Path *outer_path, Path *inner_path,
 					  JoinPathExtraData *extra)
+{
+	if (initial_cost_nestloop_hook)
+	{
+		(*initial_cost_nestloop_hook) (root, workspace,
+									   jointype,
+									   outer_path, inner_path,
+									   extra);
+	}
+	else
+	{
+		standard_initial_cost_nestloop(root, workspace,
+									   jointype,
+									   outer_path, inner_path,
+									   extra);
+	}
+}
+
+/*
+ * standard_initial_cost_nestloop
+ * 	  Default estimation for intiall nest loop cost.
+ *
+ * See initial_cost_nestloop for the meaning of the parameters.
+ */
+void
+standard_initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
+							   JoinType jointype,
+							   Path *outer_path, Path *inner_path,
+							   JoinPathExtraData *extra)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -3039,6 +3425,27 @@ void
 final_cost_nestloop(PlannerInfo *root, NestPath *path,
 					JoinCostWorkspace *workspace,
 					JoinPathExtraData *extra)
+{
+	if (final_cost_nestloop_hook)
+	{
+		(*final_cost_nestloop_hook) (root, path, workspace, extra);
+	}
+	else
+	{
+		standard_final_cost_nestloop(root, path, workspace, extra);
+	}
+}
+
+/*
+ * standard_final_cost_nestloop
+ * 	  Default estimation for actual nest loop cost.
+ *
+ * See final_cost_nestloop for the meaning of the parameters.
+ */
+void
+standard_final_cost_nestloop(PlannerInfo *root, NestPath *path,
+							 JoinCostWorkspace *workspace,
+							 JoinPathExtraData *extra)
 {
 	Path	   *outer_path = path->jpath.outerjoinpath;
 	Path	   *inner_path = path->jpath.innerjoinpath;
@@ -3248,6 +3655,40 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 					   Path *outer_path, Path *inner_path,
 					   List *outersortkeys, List *innersortkeys,
 					   JoinPathExtraData *extra)
+{
+	if (initial_cost_mergejoin_hook)
+	{
+		(*initial_cost_mergejoin_hook) (root, workspace,
+										jointype,
+										mergeclauses,
+										outer_path, inner_path,
+										outersortkeys, innersortkeys,
+										extra);
+	}
+	else
+	{
+		standard_initial_cost_mergejoin(root, workspace,
+										jointype,
+										mergeclauses,
+										outer_path, inner_path,
+										outersortkeys, innersortkeys,
+										extra);
+	}
+}
+
+/*
+ * standard_initial_cost_mergejoin
+ * 	  Default estimation for initial merge join cost.
+ *
+ * See initial_cost_mergejoin for the meaning of the parameters.
+ */
+void
+standard_initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+								JoinType jointype,
+								List *mergeclauses,
+								Path *outer_path, Path *inner_path,
+								List *outersortkeys, List *innersortkeys,
+								JoinPathExtraData *extra)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -3476,6 +3917,27 @@ void
 final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 					 JoinCostWorkspace *workspace,
 					 JoinPathExtraData *extra)
+{
+	if (final_cost_mergejoin_hook)
+	{
+		(*final_cost_mergejoin_hook) (root, path, workspace, extra);
+	}
+	else
+	{
+		standard_final_cost_mergejoin(root, path, workspace, extra);
+	}
+}
+
+/*
+ * standard_final_cost_mergejoin
+ * 	  Default estimation for actual merge join cost.
+ *
+ * See final_cost_mergejoin for the meaning of the parameters.
+ */
+void
+standard_final_cost_mergejoin(PlannerInfo *root, MergePath *path,
+							  JoinCostWorkspace *workspace,
+							  JoinPathExtraData *extra)
 {
 	Path	   *outer_path = path->jpath.outerjoinpath;
 	Path	   *inner_path = path->jpath.innerjoinpath;
@@ -3807,6 +4269,40 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 					  Path *outer_path, Path *inner_path,
 					  JoinPathExtraData *extra,
 					  bool parallel_hash)
+{
+	if (initial_cost_hashjoin_hook)
+	{
+		(*initial_cost_hashjoin_hook) (root, workspace,
+									   jointype,
+									   hashclauses,
+									   outer_path, inner_path,
+									   extra,
+									   parallel_hash);
+	}
+	else
+	{
+		standard_initial_cost_hashjoin(root, workspace,
+									   jointype,
+									   hashclauses,
+									   outer_path, inner_path,
+									   extra,
+									   parallel_hash);
+	}
+}
+
+/*
+ * standard_initial_cost_hashjoin
+ *	  Default estimation for initial hash join cost.
+ *
+ * See initial_cost_hashjoin for the meaning of the parameters.
+ */
+void
+standard_initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+							   JoinType jointype,
+							   List *hashclauses,
+							   Path *outer_path, Path *inner_path,
+							   JoinPathExtraData *extra,
+							   bool parallel_hash)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -3912,6 +4408,27 @@ void
 final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 					JoinCostWorkspace *workspace,
 					JoinPathExtraData *extra)
+{
+	if (final_cost_hashjoin_hook)
+	{
+		(*final_cost_hashjoin_hook) (root, path, workspace, extra);
+	}
+	else
+	{
+		standard_final_cost_hashjoin(root, path, workspace, extra);
+	}
+}
+
+/*
+ * standard_final_cost_hashjoin
+ *	  Default estimation for actual hash join cost.
+ *
+ * See final_cost_hashjoin for the meaning of the parameters.
+ */
+void
+standard_final_cost_hashjoin(PlannerInfo *root, HashPath *path,
+							 JoinCostWorkspace *workspace,
+							 JoinPathExtraData *extra)
 {
 	Path	   *outer_path = path->jpath.outerjoinpath;
 	Path	   *inner_path = path->jpath.innerjoinpath;
@@ -4255,10 +4772,33 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
  * plan types wherein the executor caches results explicitly, or doesn't
  * redo startup calculations, etc.
  */
-static void
+void
 cost_rescan(PlannerInfo *root, Path *path,
 			Cost *rescan_startup_cost,	/* output parameters */
 			Cost *rescan_total_cost)
+{
+	if (cost_rescan_hook)
+	{
+		(*cost_rescan_hook) (root, path,
+							 rescan_startup_cost, rescan_total_cost);
+	}
+	else
+	{
+		standard_cost_rescan(root, path,
+							 rescan_startup_cost, rescan_total_cost);
+	}
+}
+
+/*
+ * standard_cost_rescan
+ *		Default estimation for rescan cost.
+ *
+ * See cost_rescan for the meaning of the parameters.
+ */
+void
+standard_cost_rescan(PlannerInfo *root, Path *path,
+					 Cost *rescan_startup_cost, /* output parameters */
+					 Cost *rescan_total_cost)
 {
 	switch (path->pathtype)
 	{
@@ -5001,6 +5541,33 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 {
 	double		nrows;

+	if (set_baserel_size_estimates_hook)
+	{
+		nrows = (*set_baserel_size_estimates_hook) (root, rel);
+	}
+	else
+	{
+		nrows = standard_set_baserel_size_estimates(root, rel);
+	}
+
+	rel->rows = clamp_row_est(nrows);
+
+	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
+
+	set_rel_width(root, rel);
+}
+
+/*
+ * standard_set_baserel_size_estimates
+ * 			Compute the number of rows in a base relation.
+ *
+ * See set_baserel_size_estimates for a description of the parameters.
+ */
+double
+standard_set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
+{
+	double		nrows;
+
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);

@@ -5011,11 +5578,7 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 							   JOIN_INNER,
 							   NULL);

-	rel->rows = clamp_row_est(nrows);
-
-	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
-
-	set_rel_width(root, rel);
+	return nrows;
 }

 /*
@@ -5082,14 +5645,41 @@ set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
 						   SpecialJoinInfo *sjinfo,
 						   List *restrictlist)
 {
-	rel->rows = calc_joinrel_size_estimate(root,
-										   rel,
-										   outer_rel,
-										   inner_rel,
-										   outer_rel->rows,
-										   inner_rel->rows,
-										   sjinfo,
-										   restrictlist);
+	double		nrows;
+
+	if (set_joinrel_size_estimates_hook)
+	{
+		nrows = (*set_joinrel_size_estimates_hook) (root, rel, outer_rel, inner_rel,
+													sjinfo, restrictlist);
+	}
+	else
+	{
+		nrows = standard_set_joinrel_size_estimates(root, rel, outer_rel, inner_rel,
+													sjinfo, restrictlist);
+	}
+	rel->rows = nrows;
+}
+
+/*
+ * standard_set_joinrel_size_estimates
+ * 		Compute the number of rows in a join relation.
+ *
+ * See set_joinrel_size_estimates for a description of the parameters.
+ */
+double
+standard_set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+									RelOptInfo *outer_rel,
+									RelOptInfo *inner_rel,
+									SpecialJoinInfo *sjinfo,
+									List *restrictlist)
+{
+	double		nrows;
+
+	nrows = calc_joinrel_size_estimate(root, rel,
+									   outer_rel, inner_rel,
+									   outer_rel->rows, inner_rel->rows,
+									   sjinfo, restrictlist);
+	return nrows;
 }

 /*
diff --git a/src/backend/optimizer/path/joinpath.c b/src/backend/optimizer/path/joinpath.c
index 9e488eb..8c1f680 100644
--- a/src/backend/optimizer/path/joinpath.c
+++ b/src/backend/optimizer/path/joinpath.c
@@ -53,7 +53,7 @@ static void try_partial_mergejoin_path(PlannerInfo *root,
 									   List *innersortkeys,
 									   JoinType jointype,
 									   JoinPathExtraData *extra);
-static void sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+void		sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
 								 RelOptInfo *outerrel, RelOptInfo *innerrel,
 								 JoinType jointype, JoinPathExtraData *extra);
 static inline bool clause_sides_match_join(RestrictInfo *rinfo,
@@ -62,20 +62,20 @@ static inline bool clause_sides_match_join(RestrictInfo *rinfo,
 static void match_unsorted_outer(PlannerInfo *root, RelOptInfo *joinrel,
 								 RelOptInfo *outerrel, RelOptInfo *innerrel,
 								 JoinType jointype, JoinPathExtraData *extra);
-static void consider_parallel_nestloop(PlannerInfo *root,
+void		consider_parallel_nestloop(PlannerInfo *root,
 									   RelOptInfo *joinrel,
 									   RelOptInfo *outerrel,
 									   RelOptInfo *innerrel,
 									   JoinType jointype,
 									   JoinPathExtraData *extra);
-static void consider_parallel_mergejoin(PlannerInfo *root,
+void		consider_parallel_mergejoin(PlannerInfo *root,
 										RelOptInfo *joinrel,
 										RelOptInfo *outerrel,
 										RelOptInfo *innerrel,
 										JoinType jointype,
 										JoinPathExtraData *extra,
 										Path *inner_cheapest_total);
-static void hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+void		hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
 								 RelOptInfo *outerrel, RelOptInfo *innerrel,
 								 JoinType jointype, JoinPathExtraData *extra);
 static List *select_mergejoin_clauses(PlannerInfo *root,
@@ -85,7 +85,7 @@ static List *select_mergejoin_clauses(PlannerInfo *root,
 									  List *restrictlist,
 									  JoinType jointype,
 									  bool *mergejoin_allowed);
-static void generate_mergejoin_paths(PlannerInfo *root,
+void		generate_mergejoin_paths(PlannerInfo *root,
 									 RelOptInfo *joinrel,
 									 RelOptInfo *innerrel,
 									 Path *outerpath,
@@ -576,7 +576,7 @@ paraminfo_get_equal_hashops(PlannerInfo *root, ParamPathInfo *param_info,
  *		If possible, make and return a Memoize path atop of 'inner_path'.
  *		Otherwise return NULL.
  */
-static Path *
+Path *
 get_memoize_path(PlannerInfo *root, RelOptInfo *innerrel,
 				 RelOptInfo *outerrel, Path *inner_path,
 				 Path *outer_path, JoinType jointype,
@@ -716,7 +716,7 @@ get_memoize_path(PlannerInfo *root, RelOptInfo *innerrel,
  *	  Consider a nestloop join path; if it appears useful, push it into
  *	  the joinrel's pathlist via add_path().
  */
-static void
+void
 try_nestloop_path(PlannerInfo *root,
 				  RelOptInfo *joinrel,
 				  Path *outer_path,
@@ -1270,7 +1270,7 @@ clause_sides_match_join(RestrictInfo *rinfo, RelOptInfo *outerrel,
  * 'jointype' is the type of join to do
  * 'extra' contains additional input values
  */
-static void
+void
 sort_inner_and_outer(PlannerInfo *root,
 					 RelOptInfo *joinrel,
 					 RelOptInfo *outerrel,
@@ -1473,7 +1473,7 @@ sort_inner_and_outer(PlannerInfo *root,
  * mergeclause list as well as the full list.  (Ideally we'd consider all
  * subsets of the mergeclause list, but that seems way too expensive.)
  */
-static void
+void
 generate_mergejoin_paths(PlannerInfo *root,
 						 RelOptInfo *joinrel,
 						 RelOptInfo *innerrel,
@@ -1973,7 +1973,7 @@ match_unsorted_outer(PlannerInfo *root,
  * 'extra' contains additional input values
  * 'inner_cheapest_total' cheapest total path for innerrel
  */
-static void
+void
 consider_parallel_mergejoin(PlannerInfo *root,
 							RelOptInfo *joinrel,
 							RelOptInfo *outerrel,
@@ -2013,7 +2013,7 @@ consider_parallel_mergejoin(PlannerInfo *root,
  * 'jointype' is the type of join to do
  * 'extra' contains additional input values
  */
-static void
+void
 consider_parallel_nestloop(PlannerInfo *root,
 						   RelOptInfo *joinrel,
 						   RelOptInfo *outerrel,
@@ -2097,7 +2097,7 @@ consider_parallel_nestloop(PlannerInfo *root,
  * 'jointype' is the type of join to do
  * 'extra' contains additional input values
  */
-static void
+void
 hash_inner_and_outer(PlannerInfo *root,
 					 RelOptInfo *joinrel,
 					 RelOptInfo *outerrel,
diff --git a/src/backend/optimizer/path/joinrels.c b/src/backend/optimizer/path/joinrels.c
index 015a0b3..796755c 100644
--- a/src/backend/optimizer/path/joinrels.c
+++ b/src/backend/optimizer/path/joinrels.c
@@ -22,6 +22,7 @@
 #include "partitioning/partbounds.h"
 #include "utils/memutils.h"

+make_join_rel_hook_type make_join_rel_hook = NULL;

 static void make_rels_by_clause_joins(PlannerInfo *root,
 									  RelOptInfo *old_rel,
@@ -687,6 +688,23 @@ join_is_legal(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2,
  */
 RelOptInfo *
 make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)
+{
+	RelOptInfo *result;
+
+	if (make_join_rel_hook)
+	{
+		result = (*make_join_rel_hook) (root, rel1, rel2);
+	}
+	else
+	{
+		result = standard_make_join_rel(root, rel1, rel2);
+	}
+	return result;
+}
+
+
+RelOptInfo *
+standard_make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)
 {
 	Relids		joinrelids;
 	SpecialJoinInfo *sjinfo;
diff --git a/src/backend/optimizer/plan/planmain.c b/src/backend/optimizer/plan/planmain.c
index 7afd434..28984b8 100644
--- a/src/backend/optimizer/plan/planmain.c
+++ b/src/backend/optimizer/plan/planmain.c
@@ -31,6 +31,8 @@
 #include "optimizer/planmain.h"


+prepare_make_one_rel_hook_type prepare_make_one_rel_hook = NULL;
+
 /*
  * query_planner
  *	  Generate a path (that is, a simplified plan) for a basic query,
@@ -272,6 +274,9 @@ query_planner(PlannerInfo *root,
 	 */
 	distribute_row_identity_vars(root);

+	if (prepare_make_one_rel_hook)
+		prepare_make_one_rel_hook(root, joinlist);
+
 	/*
 	 * Ready to do the primary planning.
 	 */
diff --git a/src/backend/optimizer/util/pathnode.c b/src/backend/optimizer/util/pathnode.c
index bd02b7b..9c7c413 100644
--- a/src/backend/optimizer/util/pathnode.c
+++ b/src/backend/optimizer/util/pathnode.c
@@ -44,6 +44,9 @@ typedef enum
 	COSTS_DIFFERENT				/* neither path dominates the other on cost */
 } PathCostComparison;

+add_path_hook_type add_path_hook = NULL;
+add_partial_path_hook_type add_partial_path_hook = NULL;
+
 /*
  * STD_FUZZ_FACTOR is the normal fuzz factor for compare_path_costs_fuzzily.
  * XXX is it worth making this user-controllable?  It provides a tradeoff
@@ -365,8 +368,26 @@ set_cheapest(RelOptInfo *parent_rel)
 	parent_rel->cheapest_parameterized_paths = parameterized_paths;
 }

+
 /*
  * add_path
+ * 	  Consider a potential implementation path for the specified parent rel,
+ * 	  and add it to the rel's pathlist if it is worthy of consideration.
+ *
+ * 	  The precise policy followed by add_path is determined by the add_path_hook.
+ * 	  The default policy is specified by standard_add_path.
+ */
+void
+add_path(RelOptInfo *parent_rel, Path *new_path)
+{
+	if (add_path_hook)
+		(*add_path_hook) (parent_rel, new_path);
+	else
+		standard_add_path(parent_rel, new_path);
+}
+
+/*
+ * standard_add_path
  *	  Consider a potential implementation path for the specified parent rel,
  *	  and add it to the rel's pathlist if it is worthy of consideration.
  *	  A path is worthy if it has a better sort order (better pathkeys) or
@@ -424,7 +445,7 @@ set_cheapest(RelOptInfo *parent_rel)
  * Returns nothing, but modifies parent_rel->pathlist.
  */
 void
-add_path(RelOptInfo *parent_rel, Path *new_path)
+standard_add_path(RelOptInfo *parent_rel, Path *new_path)
 {
 	bool		accept_new = true;	/* unless we find a superior old path */
 	int			insert_at = 0;	/* where to insert new item */
@@ -711,6 +732,25 @@ add_path_precheck(RelOptInfo *parent_rel,
 	return true;
 }

+/*
+ * add_partial_path
+ *    Similar to add_path, but for partial paths.
+ * 	  Consider a potential implementation path for the specified parent rel,
+ * 	  and add it to the rel's partial_pathlist if it is worthy of consideration.
+ *
+ * 	  The precise policy followed by add_partial_path is determined by the
+ *    add_partial_path_hook. The default policy is specified by
+ *    standard_add_partial_path.
+ */
+void
+add_partial_path(RelOptInfo *parent_rel, Path *new_path)
+{
+	if (add_partial_path_hook)
+		(*add_partial_path_hook) (parent_rel, new_path);
+	else
+		standard_add_partial_path(parent_rel, new_path);
+}
+
 /*
  * add_partial_path
  *	  Like add_path, our goal here is to consider whether a path is worthy
@@ -751,7 +791,7 @@ add_path_precheck(RelOptInfo *parent_rel,
  *	  referenced by partial BitmapHeapPaths.
  */
 void
-add_partial_path(RelOptInfo *parent_rel, Path *new_path)
+standard_add_partial_path(RelOptInfo *parent_rel, Path *new_path)
 {
 	bool		accept_new = true;	/* unless we find a superior old path */
 	int			insert_at = 0;	/* where to insert new item */
diff --git a/src/bin/initdb/initdb.c b/src/bin/initdb/initdb.c
index 458dc11..0eb961d 100644
--- a/src/bin/initdb/initdb.c
+++ b/src/bin/initdb/initdb.c
@@ -754,15 +754,6 @@ get_id(void)
 {
 	const char *username;

-#ifndef WIN32
-	if (geteuid() == 0)			/* 0 is root's uid */
-	{
-		pg_log_error("cannot be run as root");
-		pg_log_error_hint("Please log in (using, e.g., \"su\") as the (unprivileged) user that will own the server process.");
-		exit(1);
-	}
-#endif
-
 	username = get_user_name_or_exit(progname);

 	return pg_strdup(username);
diff --git a/src/bin/pg_ctl/pg_ctl.c b/src/bin/pg_ctl/pg_ctl.c
index fc160b0..b92333c 100644
--- a/src/bin/pg_ctl/pg_ctl.c
+++ b/src/bin/pg_ctl/pg_ctl.c
@@ -2241,21 +2241,6 @@ main(int argc, char **argv)
 		}
 	}

-	/*
-	 * Disallow running as root, to forestall any possible security holes.
-	 */
-#ifndef WIN32
-	if (geteuid() == 0)
-	{
-		write_stderr(_("%s: cannot be run as root\n"
-					   "Please log in (using, e.g., \"su\") as the "
-					   "(unprivileged) user that will\n"
-					   "own the server process.\n"),
-					 progname);
-		exit(1);
-	}
-#endif
-
 	env_wait = getenv("PGCTLTIMEOUT");
 	if (env_wait != NULL)
 		wait_seconds = atoi(env_wait);
diff --git a/src/bin/pg_resetwal/pg_resetwal.c b/src/bin/pg_resetwal/pg_resetwal.c
index ca57713..aa8903c 100644
--- a/src/bin/pg_resetwal/pg_resetwal.c
+++ b/src/bin/pg_resetwal/pg_resetwal.c
@@ -324,22 +324,6 @@ main(int argc, char *argv[])
 		exit(1);
 	}

-	/*
-	 * Don't allow pg_resetwal to be run as root, to avoid overwriting the
-	 * ownership of files in the data directory. We need only check for root
-	 * -- any other user won't have sufficient permissions to modify files in
-	 * the data directory.
-	 */
-#ifndef WIN32
-	if (geteuid() == 0)
-	{
-		pg_log_error("cannot be executed by \"root\"");
-		pg_log_error_hint("You must run %s as the PostgreSQL superuser.",
-						  progname);
-		exit(1);
-	}
-#endif
-
 	get_restricted_token();

 	/* Set mask based on PGDATA permissions */
diff --git a/src/bin/pg_rewind/pg_rewind.c b/src/bin/pg_rewind/pg_rewind.c
index 53110e0..e124e39 100644
--- a/src/bin/pg_rewind/pg_rewind.c
+++ b/src/bin/pg_rewind/pg_rewind.c
@@ -261,22 +261,6 @@ main(int argc, char **argv)
 		exit(1);
 	}

-	/*
-	 * Don't allow pg_rewind to be run as root, to avoid overwriting the
-	 * ownership of files in the data directory. We need only check for root
-	 * -- any other user won't have sufficient permissions to modify files in
-	 * the data directory.
-	 */
-#ifndef WIN32
-	if (geteuid() == 0)
-	{
-		pg_log_error("cannot be executed by \"root\"");
-		pg_log_error_hint("You must run %s as the PostgreSQL superuser.",
-						  progname);
-		exit(1);
-	}
-#endif
-
 	get_restricted_token();

 	/* Set mask based on PGDATA permissions */
diff --git a/src/include/commands/explain.h b/src/include/commands/explain.h
index 3d3e632..b6b3e71 100644
--- a/src/include/commands/explain.h
+++ b/src/include/commands/explain.h
@@ -126,4 +126,14 @@ extern void ExplainOpenGroup(const char *objtype, const char *labelname,
 extern void ExplainCloseGroup(const char *objtype, const char *labelname,
 							  bool labeled, ExplainState *es);

+extern PGDLLIMPORT char *PLANNER_TYPE_UNSET;
+extern PGDLLIMPORT char *PLANNER_TYPE_CUSTOM;
+extern PGDLLIMPORT char *PLANNER_TYPE_DEFAULT;
+extern PGDLLIMPORT char *JOIN_ORDER_TYPE_CUSTOM;
+extern PGDLLIMPORT char *JOIN_ORDER_TYPE_GEQO;
+extern PGDLLIMPORT char *JOIN_ORDER_TYPE_STANDARD;
+
+extern PGDLLIMPORT char **current_planner_type;
+extern PGDLLIMPORT char **current_join_ordering_type;
+
 #endif							/* EXPLAIN_H */
diff --git a/src/include/optimizer/cost.h b/src/include/optimizer/cost.h
index 6cf4970..de64da0 100644
--- a/src/include/optimizer/cost.h
+++ b/src/include/optimizer/cost.h
@@ -72,6 +72,140 @@ extern PGDLLIMPORT bool enable_presorted_aggregate;
 extern PGDLLIMPORT bool enable_async_append;
 extern PGDLLIMPORT int constraint_exclusion;

+/* Hook for plugins to provide own cardinality estimates for base rels */
+typedef double (*set_baserel_size_estimates_hook_type) (PlannerInfo *root, RelOptInfo *rel);
+extern PGDLLIMPORT set_baserel_size_estimates_hook_type set_baserel_size_estimates_hook;
+
+/* Hook for plugins to provide own cardinality estimates for join rels */
+typedef double (*set_joinrel_size_estimates_hook_type) (PlannerInfo *root, RelOptInfo *rel,
+														RelOptInfo *outer_rel, RelOptInfo *inner_rel,
+														SpecialJoinInfo *sjinfo, List *restrictlist);
+extern PGDLLIMPORT set_joinrel_size_estimates_hook_type set_joinrel_size_estimates_hook;
+
+
+/* Hooks for cost estimation functions */
+typedef void (*cost_seqscan_hook_type) (Path *path, PlannerInfo *root, RelOptInfo *baserel,
+										ParamPathInfo *param_info);
+extern PGDLLIMPORT cost_seqscan_hook_type cost_seqscan_hook;
+
+/* XXX: missing hook for cost_samplescan */
+
+typedef void (*cost_index_hook_type) (IndexPath *path, PlannerInfo *root,
+									  double loop_count, bool partial_path);
+extern PGDLLIMPORT cost_index_hook_type cost_index_hook;
+
+typedef void (*cost_bitmap_heap_scan_hook_type) (Path *path, PlannerInfo *root, RelOptInfo *baserel,
+												 ParamPathInfo *param_info,
+												 Path *bitmapqual, double loop_count);
+extern PGDLLIMPORT cost_bitmap_heap_scan_hook_type cost_bitmap_heap_scan_hook;
+
+typedef void (*cost_bitmap_and_node_hook_type) (BitmapAndPath *path, PlannerInfo *root);
+extern PGDLLIMPORT cost_bitmap_and_node_hook_type cost_bitmap_and_node_hook;
+typedef void (*cost_bitmap_or_node_hook_type) (BitmapOrPath *path, PlannerInfo *root);
+extern PGDLLIMPORT cost_bitmap_or_node_hook_type cost_bitmap_or_node_hook;
+
+/*
+ * XXX: missing hooks for
+ * cost_tidscan cost_tidrangescan cost_subqueryscan cost_functionscan cost_valuesscan cost_tablefuncscan
+ * cost_ctescan cost_namedtuplestorescan cost_resultscan cost_recursive_union
+ */
+
+typedef void (*cost_sort_hook_type) (Path *path, PlannerInfo *root,
+									 List *pathkeys, Cost input_cost, double tuples, int width,
+									 Cost comparison_cost, int sort_mem,
+									 double limit_tuples);
+extern PGDLLIMPORT cost_sort_hook_type cost_sort_hook;
+
+typedef void (*cost_incremental_sort_hook_type) (Path *path,
+												 PlannerInfo *root, List *pathkeys, int presorted_keys,
+												 Cost input_startup_cost, Cost input_total_cost,
+												 double input_tuples, int width, Cost comparison_cost, int sort_mem,
+												 double limit_tuples);
+extern PGDLLIMPORT cost_incremental_sort_hook_type cost_incremental_sort_hook;
+
+/* XXX: missing hook for cost_append cost_merge_append */
+
+typedef void (*cost_rescan_hook_type) (PlannerInfo *root, Path *path,
+									   Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern PGDLLIMPORT cost_rescan_hook_type cost_rescan_hook;
+typedef void (*cost_memoize_rescan_hook_type) (PlannerInfo *root, MemoizePath *mpath,
+											   Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern PGDLLIMPORT cost_memoize_rescan_hook_type cost_memoize_rescan_hook;
+typedef void (*cost_material_hook_type) (Path *path,
+										 Cost input_startup_cost, Cost input_total_cost,
+										 double tuples, int width);
+extern PGDLLIMPORT cost_material_hook_type cost_material_hook;
+
+typedef void (*cost_agg_hook_type) (Path *path, PlannerInfo *root,
+									AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
+									int numGroupCols, double numGroups,
+									List *quals,
+									Cost input_startup_cost, Cost input_total_cost,
+									double input_tuples, double input_width);
+extern PGDLLIMPORT cost_agg_hook_type cost_agg_hook;
+
+typedef void (*cost_windowagg_hook_type) (Path *path, PlannerInfo *root,
+										  List *windowFuncs, int numPartCols, int numOrderCols,
+										  Cost input_startup_cost, Cost input_total_cost,
+										  double input_tuples);
+extern PGDLLIMPORT cost_windowagg_hook_type cost_windowagg_hook;
+
+typedef void (*cost_group_hook_type) (Path *path, PlannerInfo *root,
+									  int numGroupCols, double numGroups,
+									  List *quals,
+									  Cost input_startup_cost, Cost input_total_cost,
+									  double input_tuples);
+extern PGDLLIMPORT cost_group_hook_type cost_group_hook;
+
+typedef void (*initial_cost_nestloop_hook_type) (PlannerInfo *root,
+												 JoinCostWorkspace *workspace,
+												 JoinType jointype,
+												 Path *outer_path, Path *inner_path,
+												 JoinPathExtraData *extra);
+extern PGDLLIMPORT initial_cost_nestloop_hook_type initial_cost_nestloop_hook;
+typedef void (*final_cost_nestloop_hook_type) (PlannerInfo *root, NestPath *path,
+											   JoinCostWorkspace *workspace,
+											   JoinPathExtraData *extra);
+extern PGDLLIMPORT final_cost_nestloop_hook_type final_cost_nestloop_hook;
+
+typedef void (*initial_cost_mergejoin_hook_type) (PlannerInfo *root,
+												  JoinCostWorkspace *workspace,
+												  JoinType jointype,
+												  List *mergeclauses,
+												  Path *outer_path, Path *inner_path,
+												  List *outersortkeys, List *innersortkeys,
+												  JoinPathExtraData *extra);
+extern PGDLLIMPORT initial_cost_mergejoin_hook_type initial_cost_mergejoin_hook;
+typedef void (*final_cost_mergejoin_hook_type) (PlannerInfo *root, MergePath *path,
+												JoinCostWorkspace *workspace,
+												JoinPathExtraData *extra);
+extern PGDLLIMPORT final_cost_mergejoin_hook_type final_cost_mergejoin_hook;
+
+typedef void (*initial_cost_hashjoin_hook_type) (PlannerInfo *root,
+												 JoinCostWorkspace *workspace,
+												 JoinType jointype,
+												 List *hashclauses,
+												 Path *outer_path, Path *inner_path,
+												 JoinPathExtraData *extra,
+												 bool parallel_hash);
+extern PGDLLIMPORT initial_cost_hashjoin_hook_type initial_cost_hashjoin_hook;
+typedef void (*final_cost_hashjoin_hook_type) (PlannerInfo *root, HashPath *path,
+											   JoinCostWorkspace *workspace,
+											   JoinPathExtraData *extra);
+extern PGDLLIMPORT final_cost_hashjoin_hook_type final_cost_hashjoin_hook;
+
+typedef void (*cost_gather_hook_type) (GatherPath *path, PlannerInfo *root,
+									   RelOptInfo *rel, ParamPathInfo *param_info, double *rows);
+extern PGDLLIMPORT cost_gather_hook_type cost_gather_hook;
+typedef void (*cost_gather_merge_hook_type) (GatherMergePath *path, PlannerInfo *root,
+											 RelOptInfo *rel, ParamPathInfo *param_info,
+											 Cost input_startup_cost, Cost input_total_cost,
+											 double *rows);
+extern PGDLLIMPORT cost_gather_merge_hook_type cost_gather_merge_hook;
+
+/* XXX: missing for cost_subplan*/
+
+/* Prototypes for cost estimation functions */
 extern double index_pages_fetched(double tuples_fetched, BlockNumber pages,
 								  double index_pages, PlannerInfo *root);
 extern void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
@@ -124,6 +258,10 @@ extern void cost_merge_append(Path *path, PlannerInfo *root,
 extern void cost_material(Path *path,
 						  Cost input_startup_cost, Cost input_total_cost,
 						  double tuples, int width);
+extern void cost_rescan(PlannerInfo *root, Path *path,
+						Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern void cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
+								Cost *rescan_startup_cost, Cost *rescan_total_cost);
 extern void cost_agg(Path *path, PlannerInfo *root,
 					 AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
 					 int numGroupCols, double numGroups,
@@ -212,4 +350,86 @@ extern PathTarget *set_pathtarget_cost_width(PlannerInfo *root, PathTarget *targ
 extern double compute_bitmap_pages(PlannerInfo *root, RelOptInfo *baserel,
 								   Path *bitmapqual, int loop_count, Cost *cost, double *tuple);

+/* Prototypes of default cost estimation functions */
+extern void standard_cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+								  ParamPathInfo *param_info);
+extern void standard_cost_index(IndexPath *path, PlannerInfo *root,
+								double loop_count, bool partial_path);
+extern void standard_cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+										   ParamPathInfo *param_info,
+										   Path *bitmapqual, double loop_count);
+extern void standard_cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root);
+extern void standard_cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root);
+extern void standard_cost_sort(Path *path, PlannerInfo *root,
+							   List *pathkeys, Cost input_cost, double tuples, int width,
+							   Cost comparison_cost, int sort_mem,
+							   double limit_tuples);
+extern void standard_cost_incremental_sort(Path *path,
+										   PlannerInfo *root, List *pathkeys, int presorted_keys,
+										   Cost input_startup_cost, Cost input_total_cost,
+										   double input_tuples, int width, Cost comparison_cost, int sort_mem,
+										   double limit_tuples);
+extern void standard_cost_rescan(PlannerInfo *root, Path *path,
+								 Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern void standard_cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
+										 Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern void standard_cost_material(Path *path,
+								   Cost input_startup_cost, Cost input_total_cost,
+								   double tuples, int width);
+extern void standard_cost_agg(Path *path, PlannerInfo *root,
+							  AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
+							  int numGroupCols, double numGroups,
+							  List *quals,
+							  Cost input_startup_cost, Cost input_total_cost,
+							  double input_tuples, double input_width);
+extern void standard_cost_windowagg(Path *path, PlannerInfo *root,
+									List *windowFuncs, int numPartCols, int numOrderCols,
+									Cost input_startup_cost, Cost input_total_cost,
+									double input_tuples);
+extern void standard_cost_group(Path *path, PlannerInfo *root,
+								int numGroupCols, double numGroups,
+								List *quals,
+								Cost input_startup_cost, Cost input_total_cost,
+								double input_tuples);
+extern void standard_initial_cost_nestloop(PlannerInfo *root,
+										   JoinCostWorkspace *workspace,
+										   JoinType jointype,
+										   Path *outer_path, Path *inner_path,
+										   JoinPathExtraData *extra);
+extern void standard_final_cost_nestloop(PlannerInfo *root, NestPath *path,
+										 JoinCostWorkspace *workspace,
+										 JoinPathExtraData *extra);
+extern void standard_initial_cost_mergejoin(PlannerInfo *root,
+											JoinCostWorkspace *workspace,
+											JoinType jointype,
+											List *mergeclauses,
+											Path *outer_path, Path *inner_path,
+											List *outersortkeys, List *innersortkeys,
+											JoinPathExtraData *extra);
+extern void standard_final_cost_mergejoin(PlannerInfo *root, MergePath *path,
+										  JoinCostWorkspace *workspace,
+										  JoinPathExtraData *extra);
+extern void standard_initial_cost_hashjoin(PlannerInfo *root,
+										   JoinCostWorkspace *workspace,
+										   JoinType jointype,
+										   List *hashclauses,
+										   Path *outer_path, Path *inner_path,
+										   JoinPathExtraData *extra,
+										   bool parallel_hash);
+extern void standard_final_cost_hashjoin(PlannerInfo *root, HashPath *path,
+										 JoinCostWorkspace *workspace,
+										 JoinPathExtraData *extra);
+extern void standard_cost_gather(GatherPath *path, PlannerInfo *root,
+								 RelOptInfo *rel, ParamPathInfo *param_info, double *rows);
+extern void standard_cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
+									   RelOptInfo *rel, ParamPathInfo *param_info,
+									   Cost input_startup_cost, Cost input_total_cost,
+									   double *rows);
+extern double standard_set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel);
+extern double standard_set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+												  RelOptInfo *outer_rel,
+												  RelOptInfo *inner_rel,
+												  SpecialJoinInfo *sjinfo,
+												  List *restrictlist);
+
 #endif							/* COST_H */
diff --git a/src/include/optimizer/pathnode.h b/src/include/optimizer/pathnode.h
index 001e75b..7fa7c8b 100644
--- a/src/include/optimizer/pathnode.h
+++ b/src/include/optimizer/pathnode.h
@@ -18,6 +18,12 @@
 #include "nodes/pathnodes.h"


+typedef void (*add_path_hook_type) (RelOptInfo *parent_rel, Path *new_path);
+extern add_path_hook_type add_path_hook;
+
+typedef void (*add_partial_path_hook_type) (RelOptInfo *parent_rel, Path *new_path);
+extern add_partial_path_hook_type add_partial_path_hook;
+
 /*
  * prototypes for pathnode.c
  */
@@ -27,10 +33,12 @@ extern int	compare_fractional_path_costs(Path *path1, Path *path2,
 										  double fraction);
 extern void set_cheapest(RelOptInfo *parent_rel);
 extern void add_path(RelOptInfo *parent_rel, Path *new_path);
+extern void standard_add_path(RelOptInfo *parent_rel, Path *new_path);
 extern bool add_path_precheck(RelOptInfo *parent_rel,
 							  Cost startup_cost, Cost total_cost,
 							  List *pathkeys, Relids required_outer);
 extern void add_partial_path(RelOptInfo *parent_rel, Path *new_path);
+extern void standard_add_partial_path(RelOptInfo *parent_rel, Path *new_path);
 extern bool add_partial_path_precheck(RelOptInfo *parent_rel,
 									  Cost total_cost, List *pathkeys);

diff --git a/src/include/optimizer/paths.h b/src/include/optimizer/paths.h
index 50bc3b5..97f5408 100644
--- a/src/include/optimizer/paths.h
+++ b/src/include/optimizer/paths.h
@@ -47,6 +47,9 @@ typedef RelOptInfo *(*join_search_hook_type) (PlannerInfo *root,
 											  List *initial_rels);
 extern PGDLLIMPORT join_search_hook_type join_search_hook;

+typedef RelOptInfo *(*make_join_rel_hook_type) (PlannerInfo *root,
+												RelOptInfo *rel1, RelOptInfo *rel2);
+extern PGDLLIMPORT make_join_rel_hook_type make_join_rel_hook;

 extern RelOptInfo *make_one_rel(PlannerInfo *root, List *joinlist);
 extern RelOptInfo *standard_join_search(PlannerInfo *root, int levels_needed,
@@ -97,6 +100,41 @@ extern void add_paths_to_joinrel(PlannerInfo *root, RelOptInfo *joinrel,
 								 JoinType jointype, SpecialJoinInfo *sjinfo,
 								 List *restrictlist);

+extern Path *get_memoize_path(PlannerInfo *root,
+							  RelOptInfo *innerrel, RelOptInfo *outerrel,
+							  Path *inner_path, Path *outer_path,
+							  JoinType jointype, JoinPathExtraData *extra);
+
+extern void try_nestloop_path(PlannerInfo *root,
+							  RelOptInfo *joinrel,
+							  Path *outer_path, Path *inner_path,
+							  List *pathkeys,
+							  JoinType jointype, JoinPathExtraData *extra);
+
+extern void consider_parallel_nestloop(PlannerInfo *root, RelOptInfo *joinrel,
+									   RelOptInfo *outerrel, RelOptInfo *innerrel,
+									   JoinType jointype, JoinPathExtraData *extra);
+
+extern void sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+								 RelOptInfo *outerrel, RelOptInfo *innerrel,
+								 JoinType jointype, JoinPathExtraData *extra);
+
+extern void generate_mergejoin_paths(PlannerInfo *root, RelOptInfo *joinrel,
+									 RelOptInfo *innerrel, Path *outerpath,
+									 JoinType jointype, JoinPathExtraData *extra,
+									 bool useallclauses, Path *inner_cheapest_total,
+									 List *merge_pathkeys, bool is_partial);
+
+extern void consider_parallel_mergejoin(PlannerInfo *root, RelOptInfo *joinrel,
+										RelOptInfo *outerrel, RelOptInfo *innerrel,
+										JoinType jointype, JoinPathExtraData *extra,
+										Path *inner_cheapest_total);
+
+extern void hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+								 RelOptInfo *outerrel, RelOptInfo *innerrel,
+								 JoinType jointype, JoinPathExtraData *extra);
+
+
 /*
  * joinrels.c
  *	  routines to determine which relations to join
@@ -104,6 +142,8 @@ extern void add_paths_to_joinrel(PlannerInfo *root, RelOptInfo *joinrel,
 extern void join_search_one_level(PlannerInfo *root, int level);
 extern RelOptInfo *make_join_rel(PlannerInfo *root,
 								 RelOptInfo *rel1, RelOptInfo *rel2);
+extern RelOptInfo *standard_make_join_rel(PlannerInfo *root,
+										  RelOptInfo *rel1, RelOptInfo *rel2);
 extern Relids add_outer_joins_to_relids(PlannerInfo *root, Relids input_relids,
 										SpecialJoinInfo *sjinfo,
 										List **pushed_down_joins);
diff --git a/src/include/optimizer/planmain.h b/src/include/optimizer/planmain.h
index 31c1881..58597f7 100644
--- a/src/include/optimizer/planmain.h
+++ b/src/include/optimizer/planmain.h
@@ -24,6 +24,10 @@ extern PGDLLIMPORT double cursor_tuple_fraction;
 /* query_planner callback to compute query_pathkeys */
 typedef void (*query_pathkeys_callback) (PlannerInfo *root, void *extra);

+/* callback for optimizer plugins before make_one_rel is called, but after root is initialized */
+typedef void (*prepare_make_one_rel_hook_type) (PlannerInfo *root, List *joinlist);
+extern PGDLLIMPORT prepare_make_one_rel_hook_type prepare_make_one_rel_hook;
+
 /*
  * prototypes for plan/planmain.c
  */
