diff --git a/.gitignore b/.gitignore
index 4e91139..ec70caa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,3 +43,7 @@ lib*.pc
 /Release/
 /tmp_install/
 /portlock/
+
+# pg_lab specifics
+dist/
+pg.log
diff --git a/configure b/configure
index 6db03e4..733595c 100755
--- a/configure
+++ b/configure
@@ -19188,7 +19188,7 @@ fi
 
 
 cat >>confdefs.h <<_ACEOF
-#define PG_VERSION_STR "PostgreSQL $PG_VERSION on $host, compiled by $cc_string, `expr $ac_cv_sizeof_void_p \* 8`-bit"
+#define PG_VERSION_STR "PostgreSQL $PG_VERSION with pg_lab on $host, compiled by $cc_string, `expr $ac_cv_sizeof_void_p \* 8`-bit"
 _ACEOF
 
 
diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index 8086607..bd1abc8 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -25,6 +25,9 @@
 #include "nodes/extensible.h"
 #include "nodes/makefuncs.h"
 #include "nodes/nodeFuncs.h"
+#include "optimizer/geqo.h"
+#include "optimizer/paths.h"
+#include "optimizer/planner.h"
 #include "parser/analyze.h"
 #include "parser/parsetree.h"
 #include "rewrite/rewriteHandler.h"
@@ -69,6 +72,17 @@ typedef struct SerializeMetrics
  */
 #define BYTES_TO_KILOBYTES(b) (((b) + 1023) / 1024)
 
+char	  **current_planner_type = &PLANNER_TYPE_UNSET;
+extern PGDLLIMPORT planner_hook_type planner_hook;
+static planner_hook_type prev_planner_hook;
+static PlannedStmt *planner_explain_interceptor(Query *parse, const char *query_string,
+												int cursorOptions, ParamListInfo boundParams);
+
+char	  **current_join_ordering_type = &PLANNER_TYPE_UNSET;
+extern PGDLLIMPORT join_search_hook_type join_search_hook;
+static join_search_hook_type prev_join_search_hook;
+static RelOptInfo *join_search_explain_interceptor(PlannerInfo *root, int levels_needed, List *initial_rels);
+
 static void ExplainOneQuery(Query *query, int cursorOptions,
 							IntoClause *into, ExplainState *es,
 							const char *queryString, ParamListInfo params,
@@ -174,6 +188,56 @@ static void escape_yaml(StringInfo buf, const char *str);
 static SerializeMetrics GetSerializationMetrics(DestReceiver *dest);
 
 
+char	   *PLANNER_TYPE_UNSET = "<unset>";
+char	   *PLANNER_TYPE_CUSTOM = "Custom Hook";
+char	   *PLANNER_TYPE_DEFAULT = "Standard";
+char	   *JOIN_ORDER_TYPE_CUSTOM = "Custom Hook";
+char	   *JOIN_ORDER_TYPE_GEQO = "GeQO";
+char	   *JOIN_ORDER_TYPE_STANDARD = "Dynamic Programming";
+
+PlannedStmt *
+planner_explain_interceptor(Query *parse, const char *query_string, int cursorOptions, ParamListInfo boundParams)
+{
+	PlannedStmt *result;
+
+	if (prev_planner_hook)
+	{
+		current_planner_type = &PLANNER_TYPE_CUSTOM;
+		result = (*prev_planner_hook) (parse, query_string, cursorOptions, boundParams);
+	}
+	else
+	{
+		current_planner_type = &PLANNER_TYPE_DEFAULT;
+		result = standard_planner(parse, query_string, cursorOptions, boundParams);
+	}
+
+	return result;
+}
+
+
+RelOptInfo *
+join_search_explain_interceptor(PlannerInfo *root, int levels_needed, List *initial_rels)
+{
+	RelOptInfo *result;
+
+	if (prev_join_search_hook)
+	{
+		current_join_ordering_type = &JOIN_ORDER_TYPE_CUSTOM;
+		result = (*prev_join_search_hook) (root, levels_needed, initial_rels);
+	}
+	else if (enable_geqo && levels_needed >= geqo_threshold)
+	{
+		current_join_ordering_type = &JOIN_ORDER_TYPE_GEQO;
+		result = geqo(root, levels_needed, initial_rels);
+	}
+	else
+	{
+		current_join_ordering_type = &JOIN_ORDER_TYPE_STANDARD;
+		result = standard_join_search(root, levels_needed, initial_rels);
+	}
+
+	return result;
+}
 
 /*
  * ExplainQuery -
@@ -487,7 +551,23 @@ standard_ExplainOneQuery(Query *query, int cursorOptions,
 	INSTR_TIME_SET_CURRENT(planstart);
 
 	/* plan the query */
-	plan = pg_plan_query(query, queryString, cursorOptions, params);
+    prev_planner_hook = planner_hook;
+    planner_hook = planner_explain_interceptor;
+    prev_join_search_hook = join_search_hook;
+    join_search_hook = join_search_explain_interceptor;
+
+    PG_TRY();
+    {
+        plan = pg_plan_query(query, queryString, cursorOptions, params);
+    }
+    PG_FINALLY();
+    {
+        planner_hook = prev_planner_hook;
+        prev_planner_hook = NULL;
+        join_search_hook = prev_join_search_hook;
+        prev_join_search_hook = NULL;
+    }
+    PG_END_TRY();
 
 	INSTR_TIME_SET_CURRENT(planduration);
 	INSTR_TIME_SUBTRACT(planduration, planstart);
@@ -509,6 +589,24 @@ standard_ExplainOneQuery(Query *query, int cursorOptions,
 	ExplainOnePlan(plan, into, es, queryString, params, queryEnv,
 				   &planduration, (es->buffers ? &bufusage : NULL),
 				   es->memory ? &mem_counters : NULL);
+
+    if (es->format == EXPLAIN_FORMAT_TEXT)
+    {
+        ExplainOpenGroup("Optimizer", "Optimizer", true, es);
+        ExplainIndentText(es);
+        appendStringInfo(es->str, "Optimizer: planner=%s", *current_planner_type);
+        appendStringInfo(es->str, " joinorder=%s", *current_join_ordering_type);
+        ExplainCloseGroup("Optimizer", "Optimizer", true, es);
+    }
+    else
+    {
+        ExplainOpenGroup("OptimizerInfo", NULL, true, es);
+        ExplainOpenGroup("Optimizer", "Optimizer", true, es);
+        ExplainPropertyText("Planner", *current_planner_type, es);
+        ExplainPropertyText("Join Ordering", *current_join_ordering_type, es);
+        ExplainCloseGroup("Optimizer", "Optimizer", true, es);
+        ExplainCloseGroup("OptimizerInfo", NULL, true, es);
+    }
 }
 
 /*
diff --git a/src/backend/main/main.c b/src/backend/main/main.c
index 4672aab..87ae031 100644
--- a/src/backend/main/main.c
+++ b/src/backend/main/main.c
@@ -57,7 +57,7 @@ static void check_root(const char *progname);
 int
 main(int argc, char *argv[])
 {
-	bool		do_check_root = true;
+	bool		do_check_root = false;
 
 	reached_main = true;
 
@@ -378,6 +378,8 @@ help(const char *progname)
 static void
 check_root(const char *progname)
 {
+    return;
+
 #ifndef WIN32
 	if (geteuid() == 0)
 	{
diff --git a/src/backend/optimizer/path/costsize.c b/src/backend/optimizer/path/costsize.c
index 52ebdd9..119d18a 100644
--- a/src/backend/optimizer/path/costsize.c
+++ b/src/backend/optimizer/path/costsize.c
@@ -153,6 +153,38 @@ bool		enable_partition_pruning = true;
 bool		enable_presorted_aggregate = true;
 bool		enable_async_append = true;
 
+cost_seqscan_hook_type  cost_seqscan_hook = NULL;
+cost_index_hook_type    cost_index_hook = NULL;
+
+cost_bitmap_heap_scan_hook_type     cost_bitmap_heap_scan_hook = NULL;
+cost_bitmap_and_node_hook_type      cost_bitmap_and_node_hook = NULL;
+cost_bitmap_or_node_hook_type       cost_bitmap_or_node_hook = NULL;
+
+cost_sort_hook_type                 cost_sort_hook = NULL;
+cost_incremental_sort_hook_type     cost_incremental_sort_hook = NULL;
+
+cost_material_hook_type         cost_material_hook = NULL;
+cost_rescan_hook_type           cost_rescan_hook = NULL;
+cost_memoize_rescan_hook_type   cost_memoize_rescan_hook = NULL;
+
+cost_agg_hook_type          cost_agg_hook = NULL;
+cost_windowagg_hook_type    cost_windowagg_hook = NULL;
+cost_group_hook_type        cost_group_hook = NULL;
+
+initial_cost_nestloop_hook_type     initial_cost_nestloop_hook = NULL;
+final_cost_nestloop_hook_type       final_cost_nestloop_hook = NULL;
+initial_cost_mergejoin_hook_type    initial_cost_mergejoin_hook = NULL;
+final_cost_mergejoin_hook_type      final_cost_mergejoin_hook = NULL;
+initial_cost_hashjoin_hook_type     initial_cost_hashjoin_hook = NULL;
+final_cost_hashjoin_hook_type       final_cost_hashjoin_hook = NULL;
+
+cost_gather_hook_type           cost_gather_hook = NULL;
+cost_gather_merge_hook_type     cost_gather_merge_hook = NULL;
+
+set_baserel_size_estimates_hook_type    set_baserel_size_estimates_hook = NULL;
+set_joinrel_size_estimates_hook_type    set_joinrel_size_estimates_hook = NULL;
+
+
 typedef struct
 {
 	PlannerInfo *root;
@@ -163,8 +195,6 @@ static List *extract_nonindex_conditions(List *qual_clauses, List *indexclauses)
 static MergeScanSelCache *cached_scansel(PlannerInfo *root,
 										 RestrictInfo *rinfo,
 										 PathKey *pathkey);
-static void cost_rescan(PlannerInfo *root, Path *path,
-						Cost *rescan_startup_cost, Cost *rescan_total_cost);
 static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context);
 static void get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
 									  ParamPathInfo *param_info,
@@ -283,6 +313,26 @@ clamp_cardinality_to_long(Cardinality x)
 void
 cost_seqscan(Path *path, PlannerInfo *root,
 			 RelOptInfo *baserel, ParamPathInfo *param_info)
+{
+    if (cost_seqscan_hook)
+	{
+		(*cost_seqscan_hook) (path, root, baserel, param_info);
+	}
+	else
+	{
+		standard_cost_seqscan(path, root, baserel, param_info);
+	}
+}
+
+/*
+ * standard_cost_seqscan
+ * 	  Default cost estimation for sequential scans.
+ *
+ * See cost_seqscan for the meaning of the parameters.
+ */
+void
+standard_cost_seqscan(Path *path, PlannerInfo *root,
+					  RelOptInfo *baserel, ParamPathInfo *param_info)
 {
 	Cost		startup_cost = 0;
 	Cost		cpu_run_cost;
@@ -436,6 +486,27 @@ void
 cost_gather(GatherPath *path, PlannerInfo *root,
 			RelOptInfo *rel, ParamPathInfo *param_info,
 			double *rows)
+{
+    if (cost_gather_hook)
+	{
+		(*cost_gather_hook) (path, root, rel, param_info, rows);
+	}
+	else
+	{
+		standard_cost_gather(path, root, rel, param_info, rows);
+	}
+}
+
+/*
+ * standard_cost_gather
+ *	  Default cost estimation for Gather nodes.
+ *
+ * See cost_gather for the meaning of the parameters.
+ */
+void
+standard_cost_gather(GatherPath *path, PlannerInfo *root,
+					 RelOptInfo *rel, ParamPathInfo *param_info,
+					 double *rows)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -475,6 +546,30 @@ cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
 				  RelOptInfo *rel, ParamPathInfo *param_info,
 				  Cost input_startup_cost, Cost input_total_cost,
 				  double *rows)
+{
+	if (cost_gather_merge_hook)
+	{
+		(*cost_gather_merge_hook) (path, root, rel, param_info,
+								   input_startup_cost, input_total_cost, rows);
+	}
+	else
+	{
+		standard_cost_gather_merge(path, root, rel, param_info,
+								   input_startup_cost, input_total_cost, rows);
+	}
+}
+
+/*
+ * standard_cost_gather_merge
+ *	  Default cost estimation for Gather Merge nodes.
+ *
+ * See cost_gather_merge for the meaning of the parameters.
+ */
+void
+standard_cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
+						   RelOptInfo *rel, ParamPathInfo *param_info,
+						   Cost input_startup_cost, Cost input_total_cost,
+						   double *rows)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -548,6 +643,26 @@ cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
 void
 cost_index(IndexPath *path, PlannerInfo *root, double loop_count,
 		   bool partial_path)
+{
+	if (cost_index_hook)
+	{
+		(*cost_index_hook) (path, root, loop_count, partial_path);
+	}
+	else
+	{
+		standard_cost_index(path, root, loop_count, partial_path);
+	}
+}
+
+/*
+ * standard_cost_index
+ *	  Default cost estimation for index scans.
+ *
+ * See cost_index for the meaning of the parameters.
+ */
+void
+standard_cost_index(IndexPath *path, PlannerInfo *root, double loop_count,
+					bool partial_path)
 {
 	IndexOptInfo *index = path->indexinfo;
 	RelOptInfo *baserel = index->rel;
@@ -1013,6 +1128,29 @@ void
 cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 					  ParamPathInfo *param_info,
 					  Path *bitmapqual, double loop_count)
+{
+	if (cost_bitmap_heap_scan_hook)
+	{
+		(*cost_bitmap_heap_scan_hook) (path, root, baserel, param_info,
+									   bitmapqual, loop_count);
+	}
+	else
+	{
+		standard_cost_bitmap_heap_scan(path, root, baserel, param_info,
+									   bitmapqual, loop_count);
+	}
+}
+
+/*
+ * standard_cost_bitmap_heap_scan
+ * 		Default cost estimation for bitmap heap scans.
+ *
+ * See cost_bitmap_heap_scan for the meaning of the parameters.
+ */
+void
+standard_cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+							   ParamPathInfo *param_info,
+							   Path *bitmapqual, double loop_count)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -1155,6 +1293,25 @@ cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
  */
 void
 cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
+{
+	if (cost_bitmap_and_node_hook)
+	{
+		(*cost_bitmap_and_node_hook) (path, root);
+	}
+	else
+	{
+		standard_cost_bitmap_and_node(path, root);
+	}
+}
+
+/*
+ * standard_cost_bitmap_and_node
+ *	  Default cost estimation for BitmapAnd nodes.
+ *
+ * See cost_bitmap_and_node for the meaning of the parameters.
+ */
+void
+standard_cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
 {
 	Cost		totalCost;
 	Selectivity selec;
@@ -1199,6 +1356,25 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
  */
 void
 cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
+{
+	if (cost_bitmap_or_node_hook)
+	{
+		(*cost_bitmap_or_node_hook) (path, root);
+	}
+	else
+	{
+		standard_cost_bitmap_or_node(path, root);
+	}
+}
+
+/*
+ * standard_cost_bitmap_or_node
+ *	  Default cost estimation for BitmapOr nodes.
+ *
+ * See cost_bitmap_or_node for the meaning of the parameters.
+ */
+void
+standard_cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
 {
 	Cost		totalCost;
 	Selectivity selec;
@@ -1988,6 +2164,35 @@ cost_incremental_sort(Path *path,
 					  Cost input_startup_cost, Cost input_total_cost,
 					  double input_tuples, int width, Cost comparison_cost, int sort_mem,
 					  double limit_tuples)
+{
+	if (cost_incremental_sort_hook)
+	{
+		(*cost_incremental_sort_hook) (path, root, pathkeys, presorted_keys,
+									   input_startup_cost, input_total_cost,
+									   input_tuples, width, comparison_cost,
+									   sort_mem, limit_tuples);
+	}
+	else
+	{
+		standard_cost_incremental_sort(path, root, pathkeys, presorted_keys,
+									   input_startup_cost, input_total_cost,
+									   input_tuples, width, comparison_cost,
+									   sort_mem, limit_tuples);
+	}
+}
+
+/*
+ * standard_cost_incremental_sort
+ * 		Default estimation for incremental sort.
+ *
+ * See cost_incremental_sort for the meaning of the parameters.
+ */
+void
+standard_cost_incremental_sort(Path *path,
+							   PlannerInfo *root, List *pathkeys, int presorted_keys,
+							   Cost input_startup_cost, Cost input_total_cost,
+							   double input_tuples, int width, Cost comparison_cost, int sort_mem,
+							   double limit_tuples)
 {
 	Cost		startup_cost,
 				run_cost,
@@ -2125,7 +2330,30 @@ cost_sort(Path *path, PlannerInfo *root,
 		  List *pathkeys, Cost input_cost, double tuples, int width,
 		  Cost comparison_cost, int sort_mem,
 		  double limit_tuples)
+{
+	if (cost_sort_hook)
+	{
+		(*cost_sort_hook) (path, root, pathkeys, input_cost, tuples, width,
+						   comparison_cost, sort_mem, limit_tuples);
+	}
+	else
+	{
+		standard_cost_sort(path, root, pathkeys, input_cost, tuples, width,
+						   comparison_cost, sort_mem, limit_tuples);
+	}
+}
 
+/*
+ * standard_cost_sort
+ * 		Default estimation for sort.
+ *
+ * See cost_sort for the meaning of the parameters.
+ */
+void
+standard_cost_sort(Path *path, PlannerInfo *root,
+				   List *pathkeys, Cost input_cost, double tuples, int width,
+				   Cost comparison_cost, int sort_mem,
+				   double limit_tuples)
 {
 	Cost		startup_cost;
 	Cost		run_cost;
@@ -2453,6 +2681,28 @@ void
 cost_material(Path *path,
 			  Cost input_startup_cost, Cost input_total_cost,
 			  double tuples, int width)
+{
+	if (cost_material_hook)
+	{
+		(*cost_material_hook) (path, input_startup_cost, input_total_cost,
+							   tuples, width);
+	}
+	else
+	{
+		standard_cost_material(path, input_startup_cost, input_total_cost,
+							   tuples, width);
+	}
+}
+
+/*
+ * standard_cost_material
+ *	  Default cost estimation for materialization.
+ * See cost_material for the meaning of the parameters.
+ */
+void
+standard_cost_material(Path *path,
+					   Cost input_startup_cost, Cost input_total_cost,
+					   double tuples, int width)
 {
 	Cost		startup_cost = input_startup_cost;
 	Cost		run_cost = input_total_cost - input_startup_cost;
@@ -2505,9 +2755,31 @@ cost_material(Path *path,
  * never see any parameter value twice, in which case we'd never get a cache
  * hit and caching would be a complete waste of effort.
  */
-static void
+void
 cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
 					Cost *rescan_startup_cost, Cost *rescan_total_cost)
+{
+	if (cost_memoize_rescan_hook)
+	{
+		(*cost_memoize_rescan_hook) (root, mpath,
+									 rescan_startup_cost, rescan_total_cost);
+	}
+	else
+	{
+		standard_cost_memoize_rescan(root, mpath,
+									 rescan_startup_cost, rescan_total_cost);
+	}
+}
+
+/*
+ * standard_cost_memoize_rescan
+ *	  Default cost estimation a Memoize node.
+ *
+ * See cost_memoize_rescan for the meaning of the parameters.
+ */
+void
+standard_cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
+							 Cost *rescan_startup_cost, Cost *rescan_total_cost)
 {
 	EstimationInfo estinfo;
 	ListCell   *lc;
@@ -2653,6 +2925,39 @@ cost_agg(Path *path, PlannerInfo *root,
 		 List *quals,
 		 Cost input_startup_cost, Cost input_total_cost,
 		 double input_tuples, double input_width)
+{
+	if (cost_agg_hook)
+	{
+		(*cost_agg_hook) (path, root,
+						  aggstrategy, aggcosts,
+						  numGroupCols, numGroups,
+						  quals,
+						  input_startup_cost, input_total_cost,
+						  input_tuples, input_width);
+	}
+	else
+	{
+		standard_cost_agg(path, root,
+						  aggstrategy, aggcosts,
+						  numGroupCols, numGroups,
+						  quals,
+						  input_startup_cost, input_total_cost,
+						  input_tuples, input_width);
+	}
+}
+
+/*
+ * standard_cost_agg
+ *		Default cost estimation for Aggregation nodes.
+ * See cost_agg for the meaning of the parameters.
+ */
+void
+standard_cost_agg(Path *path, PlannerInfo *root,
+				  AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
+				  int numGroupCols, double numGroups,
+				  List *quals,
+				  Cost input_startup_cost, Cost input_total_cost,
+				  double input_tuples, double input_width)
 {
 	double		output_tuples;
 	Cost		startup_cost;
@@ -3069,6 +3374,34 @@ cost_windowagg(Path *path, PlannerInfo *root,
 			   List *windowFuncs, WindowClause *winclause,
 			   Cost input_startup_cost, Cost input_total_cost,
 			   double input_tuples)
+{
+	if (cost_windowagg_hook)
+	{
+		(*cost_windowagg_hook) (path, root,
+								windowFuncs, winclause,
+								input_startup_cost, input_total_cost,
+								input_tuples);
+	}
+	else
+	{
+		standard_cost_windowagg(path, root,
+								windowFuncs, winclause,
+								input_startup_cost, input_total_cost,
+								input_tuples);
+	}
+}
+
+/*
+ * standard_cost_windowagg
+ *		Default cost estimation for WindowAgg nodes.
+ *
+ * See cost_windowagg for the meaning of the parameters.
+ */
+void
+standard_cost_windowagg(Path *path, PlannerInfo *root,
+						List *windowFuncs, WindowClause *winclause,
+						Cost input_startup_cost, Cost input_total_cost,
+						double input_tuples)
 {
 	Cost		startup_cost;
 	Cost		total_cost;
@@ -3165,6 +3498,37 @@ cost_group(Path *path, PlannerInfo *root,
 		   List *quals,
 		   Cost input_startup_cost, Cost input_total_cost,
 		   double input_tuples)
+{
+	if (cost_group_hook)
+	{
+		(*cost_group_hook) (path, root,
+							numGroupCols, numGroups,
+							quals,
+							input_startup_cost, input_total_cost,
+							input_tuples);
+	}
+	else
+	{
+		standard_cost_group(path, root,
+							numGroupCols, numGroups,
+							quals,
+							input_startup_cost, input_total_cost,
+							input_tuples);
+	}
+}
+
+/*
+ * standard_cost_group
+ *		Default cost estimation for Group nodes.
+ *
+ * See cost_group for the meaning of the parameters.
+ */
+void
+standard_cost_group(Path *path, PlannerInfo *root,
+					int numGroupCols, double numGroups,
+					List *quals,
+					Cost input_startup_cost, Cost input_total_cost,
+					double input_tuples)
 {
 	double		output_tuples;
 	Cost		startup_cost;
@@ -3234,6 +3598,34 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 					  JoinType jointype,
 					  Path *outer_path, Path *inner_path,
 					  JoinPathExtraData *extra)
+{
+	if (initial_cost_nestloop_hook)
+	{
+		(*initial_cost_nestloop_hook) (root, workspace,
+									   jointype,
+									   outer_path, inner_path,
+									   extra);
+	}
+	else
+	{
+		standard_initial_cost_nestloop(root, workspace,
+									   jointype,
+									   outer_path, inner_path,
+									   extra);
+	}
+}
+
+/*
+ * standard_initial_cost_nestloop
+ * 	  Default estimation for intiall nest loop cost.
+ *
+ * See initial_cost_nestloop for the meaning of the parameters.
+ */
+void
+standard_initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
+							   JoinType jointype,
+							   Path *outer_path, Path *inner_path,
+							   JoinPathExtraData *extra)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -3308,6 +3700,27 @@ void
 final_cost_nestloop(PlannerInfo *root, NestPath *path,
 					JoinCostWorkspace *workspace,
 					JoinPathExtraData *extra)
+{
+	if (final_cost_nestloop_hook)
+	{
+		(*final_cost_nestloop_hook) (root, path, workspace, extra);
+	}
+	else
+	{
+		standard_final_cost_nestloop(root, path, workspace, extra);
+	}
+}
+
+/*
+ * standard_final_cost_nestloop
+ * 	  Default estimation for actual nest loop cost.
+ *
+ * See final_cost_nestloop for the meaning of the parameters.
+ */
+void
+standard_final_cost_nestloop(PlannerInfo *root, NestPath *path,
+							 JoinCostWorkspace *workspace,
+							 JoinPathExtraData *extra)
 {
 	Path	   *outer_path = path->jpath.outerjoinpath;
 	Path	   *inner_path = path->jpath.innerjoinpath;
@@ -3517,6 +3930,40 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 					   Path *outer_path, Path *inner_path,
 					   List *outersortkeys, List *innersortkeys,
 					   JoinPathExtraData *extra)
+{
+	if (initial_cost_mergejoin_hook)
+	{
+		(*initial_cost_mergejoin_hook) (root, workspace,
+										jointype,
+										mergeclauses,
+										outer_path, inner_path,
+										outersortkeys, innersortkeys,
+										extra);
+	}
+	else
+	{
+		standard_initial_cost_mergejoin(root, workspace,
+										jointype,
+										mergeclauses,
+										outer_path, inner_path,
+										outersortkeys, innersortkeys,
+										extra);
+	}
+}
+
+/*
+ * standard_initial_cost_mergejoin
+ * 	  Default estimation for initial merge join cost.
+ *
+ * See initial_cost_mergejoin for the meaning of the parameters.
+ */
+void
+standard_initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+								JoinType jointype,
+								List *mergeclauses,
+								Path *outer_path, Path *inner_path,
+								List *outersortkeys, List *innersortkeys,
+								JoinPathExtraData *extra)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -3745,6 +4192,27 @@ void
 final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 					 JoinCostWorkspace *workspace,
 					 JoinPathExtraData *extra)
+{
+	if (final_cost_mergejoin_hook)
+	{
+		(*final_cost_mergejoin_hook) (root, path, workspace, extra);
+	}
+	else
+	{
+		standard_final_cost_mergejoin(root, path, workspace, extra);
+	}
+}
+
+/*
+ * standard_final_cost_mergejoin
+ * 	  Default estimation for actual merge join cost.
+ *
+ * See final_cost_mergejoin for the meaning of the parameters.
+ */
+void
+standard_final_cost_mergejoin(PlannerInfo *root, MergePath *path,
+							  JoinCostWorkspace *workspace,
+							  JoinPathExtraData *extra)
 {
 	Path	   *outer_path = path->jpath.outerjoinpath;
 	Path	   *inner_path = path->jpath.innerjoinpath;
@@ -4076,6 +4544,40 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 					  Path *outer_path, Path *inner_path,
 					  JoinPathExtraData *extra,
 					  bool parallel_hash)
+{
+	if (initial_cost_hashjoin_hook)
+	{
+		(*initial_cost_hashjoin_hook) (root, workspace,
+									   jointype,
+									   hashclauses,
+									   outer_path, inner_path,
+									   extra,
+									   parallel_hash);
+	}
+	else
+	{
+		standard_initial_cost_hashjoin(root, workspace,
+									   jointype,
+									   hashclauses,
+									   outer_path, inner_path,
+									   extra,
+									   parallel_hash);
+	}
+}
+
+/*
+ * standard_initial_cost_hashjoin
+ *	  Default estimation for initial hash join cost.
+ *
+ * See initial_cost_hashjoin for the meaning of the parameters.
+ */
+void
+standard_initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+							   JoinType jointype,
+							   List *hashclauses,
+							   Path *outer_path, Path *inner_path,
+							   JoinPathExtraData *extra,
+							   bool parallel_hash)
 {
 	Cost		startup_cost = 0;
 	Cost		run_cost = 0;
@@ -4181,6 +4683,27 @@ void
 final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 					JoinCostWorkspace *workspace,
 					JoinPathExtraData *extra)
+{
+	if (final_cost_hashjoin_hook)
+	{
+		(*final_cost_hashjoin_hook) (root, path, workspace, extra);
+	}
+	else
+	{
+		standard_final_cost_hashjoin(root, path, workspace, extra);
+	}
+}
+
+/*
+ * standard_final_cost_hashjoin
+ *	  Default estimation for actual hash join cost.
+ *
+ * See final_cost_hashjoin for the meaning of the parameters.
+ */
+void
+standard_final_cost_hashjoin(PlannerInfo *root, HashPath *path,
+							 JoinCostWorkspace *workspace,
+							 JoinPathExtraData *extra)
 {
 	Path	   *outer_path = path->jpath.outerjoinpath;
 	Path	   *inner_path = path->jpath.innerjoinpath;
@@ -4524,10 +5047,33 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
  * plan types wherein the executor caches results explicitly, or doesn't
  * redo startup calculations, etc.
  */
-static void
+void
 cost_rescan(PlannerInfo *root, Path *path,
 			Cost *rescan_startup_cost,	/* output parameters */
 			Cost *rescan_total_cost)
+{
+	if (cost_rescan_hook)
+	{
+		(*cost_rescan_hook) (root, path,
+							 rescan_startup_cost, rescan_total_cost);
+	}
+	else
+	{
+		standard_cost_rescan(root, path,
+							 rescan_startup_cost, rescan_total_cost);
+	}
+}
+
+/*
+ * standard_cost_rescan
+ *		Default estimation for rescan cost.
+ *
+ * See cost_rescan for the meaning of the parameters.
+ */
+void
+standard_cost_rescan(PlannerInfo *root, Path *path,
+					 Cost *rescan_startup_cost, /* output parameters */
+					 Cost *rescan_total_cost)
 {
 	switch (path->pathtype)
 	{
@@ -5243,6 +5789,33 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 {
 	double		nrows;
 
+	if (set_baserel_size_estimates_hook)
+	{
+		nrows = (*set_baserel_size_estimates_hook) (root, rel);
+	}
+	else
+	{
+		nrows = standard_set_baserel_size_estimates(root, rel);
+	}
+
+	rel->rows = clamp_row_est(nrows);
+
+	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
+
+	set_rel_width(root, rel);
+}
+
+/*
+ * standard_set_baserel_size_estimates
+ * 			Compute the number of rows in a base relation.
+ *
+ * See set_baserel_size_estimates for a description of the parameters.
+ */
+double
+standard_set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
+{
+	double		nrows;
+
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
@@ -5253,11 +5826,7 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 							   JOIN_INNER,
 							   NULL);
 
-	rel->rows = clamp_row_est(nrows);
-
-	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
-
-	set_rel_width(root, rel);
+	return nrows;
 }
 
 /*
@@ -5324,14 +5893,41 @@ set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
 						   SpecialJoinInfo *sjinfo,
 						   List *restrictlist)
 {
-	rel->rows = calc_joinrel_size_estimate(root,
-										   rel,
-										   outer_rel,
-										   inner_rel,
-										   outer_rel->rows,
-										   inner_rel->rows,
-										   sjinfo,
-										   restrictlist);
+	double		nrows;
+
+	if (set_joinrel_size_estimates_hook)
+	{
+		nrows = (*set_joinrel_size_estimates_hook) (root, rel, outer_rel, inner_rel,
+													sjinfo, restrictlist);
+	}
+	else
+	{
+		nrows = standard_set_joinrel_size_estimates(root, rel, outer_rel, inner_rel,
+													sjinfo, restrictlist);
+	}
+	rel->rows = nrows;
+}
+
+/*
+ * standard_set_joinrel_size_estimates
+ * 		Compute the number of rows in a join relation.
+ *
+ * See set_joinrel_size_estimates for a description of the parameters.
+ */
+double
+standard_set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+									RelOptInfo *outer_rel,
+									RelOptInfo *inner_rel,
+									SpecialJoinInfo *sjinfo,
+									List *restrictlist)
+{
+	double		nrows;
+
+	nrows = calc_joinrel_size_estimate(root, rel,
+									   outer_rel, inner_rel,
+									   outer_rel->rows, inner_rel->rows,
+									   sjinfo, restrictlist);
+	return nrows;
 }
 
 /*
diff --git a/src/backend/optimizer/path/joinpath.c b/src/backend/optimizer/path/joinpath.c
index 5be8da9..ad10b59 100644
--- a/src/backend/optimizer/path/joinpath.c
+++ b/src/backend/optimizer/path/joinpath.c
@@ -53,7 +53,7 @@ static void try_partial_mergejoin_path(PlannerInfo *root,
 									   List *innersortkeys,
 									   JoinType jointype,
 									   JoinPathExtraData *extra);
-static void sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+void		sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
 								 RelOptInfo *outerrel, RelOptInfo *innerrel,
 								 JoinType jointype, JoinPathExtraData *extra);
 static inline bool clause_sides_match_join(RestrictInfo *rinfo,
@@ -62,20 +62,20 @@ static inline bool clause_sides_match_join(RestrictInfo *rinfo,
 static void match_unsorted_outer(PlannerInfo *root, RelOptInfo *joinrel,
 								 RelOptInfo *outerrel, RelOptInfo *innerrel,
 								 JoinType jointype, JoinPathExtraData *extra);
-static void consider_parallel_nestloop(PlannerInfo *root,
+void		consider_parallel_nestloop(PlannerInfo *root,
 									   RelOptInfo *joinrel,
 									   RelOptInfo *outerrel,
 									   RelOptInfo *innerrel,
 									   JoinType jointype,
 									   JoinPathExtraData *extra);
-static void consider_parallel_mergejoin(PlannerInfo *root,
+void		consider_parallel_mergejoin(PlannerInfo *root,
 										RelOptInfo *joinrel,
 										RelOptInfo *outerrel,
 										RelOptInfo *innerrel,
 										JoinType jointype,
 										JoinPathExtraData *extra,
 										Path *inner_cheapest_total);
-static void hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+void		hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
 								 RelOptInfo *outerrel, RelOptInfo *innerrel,
 								 JoinType jointype, JoinPathExtraData *extra);
 static List *select_mergejoin_clauses(PlannerInfo *root,
@@ -85,7 +85,7 @@ static List *select_mergejoin_clauses(PlannerInfo *root,
 									  List *restrictlist,
 									  JoinType jointype,
 									  bool *mergejoin_allowed);
-static void generate_mergejoin_paths(PlannerInfo *root,
+void		generate_mergejoin_paths(PlannerInfo *root,
 									 RelOptInfo *joinrel,
 									 RelOptInfo *innerrel,
 									 Path *outerpath,
@@ -577,7 +577,7 @@ paraminfo_get_equal_hashops(PlannerInfo *root, ParamPathInfo *param_info,
  *		If possible, make and return a Memoize path atop of 'inner_path'.
  *		Otherwise return NULL.
  */
-static Path *
+Path *
 get_memoize_path(PlannerInfo *root, RelOptInfo *innerrel,
 				 RelOptInfo *outerrel, Path *inner_path,
 				 Path *outer_path, JoinType jointype,
@@ -717,7 +717,7 @@ get_memoize_path(PlannerInfo *root, RelOptInfo *innerrel,
  *	  Consider a nestloop join path; if it appears useful, push it into
  *	  the joinrel's pathlist via add_path().
  */
-static void
+void
 try_nestloop_path(PlannerInfo *root,
 				  RelOptInfo *joinrel,
 				  Path *outer_path,
@@ -1262,7 +1262,7 @@ clause_sides_match_join(RestrictInfo *rinfo, RelOptInfo *outerrel,
  * 'jointype' is the type of join to do
  * 'extra' contains additional input values
  */
-static void
+void
 sort_inner_and_outer(PlannerInfo *root,
 					 RelOptInfo *joinrel,
 					 RelOptInfo *outerrel,
@@ -1465,7 +1465,7 @@ sort_inner_and_outer(PlannerInfo *root,
  * mergeclause list as well as the full list.  (Ideally we'd consider all
  * subsets of the mergeclause list, but that seems way too expensive.)
  */
-static void
+void
 generate_mergejoin_paths(PlannerInfo *root,
 						 RelOptInfo *joinrel,
 						 RelOptInfo *innerrel,
@@ -1965,7 +1965,7 @@ match_unsorted_outer(PlannerInfo *root,
  * 'extra' contains additional input values
  * 'inner_cheapest_total' cheapest total path for innerrel
  */
-static void
+void
 consider_parallel_mergejoin(PlannerInfo *root,
 							RelOptInfo *joinrel,
 							RelOptInfo *outerrel,
@@ -2005,7 +2005,7 @@ consider_parallel_mergejoin(PlannerInfo *root,
  * 'jointype' is the type of join to do
  * 'extra' contains additional input values
  */
-static void
+void
 consider_parallel_nestloop(PlannerInfo *root,
 						   RelOptInfo *joinrel,
 						   RelOptInfo *outerrel,
@@ -2089,7 +2089,7 @@ consider_parallel_nestloop(PlannerInfo *root,
  * 'jointype' is the type of join to do
  * 'extra' contains additional input values
  */
-static void
+void
 hash_inner_and_outer(PlannerInfo *root,
 					 RelOptInfo *joinrel,
 					 RelOptInfo *outerrel,
diff --git a/src/backend/optimizer/path/joinrels.c b/src/backend/optimizer/path/joinrels.c
index db475e2..786303c 100644
--- a/src/backend/optimizer/path/joinrels.c
+++ b/src/backend/optimizer/path/joinrels.c
@@ -22,6 +22,7 @@
 #include "partitioning/partbounds.h"
 #include "utils/memutils.h"
 
+make_join_rel_hook_type make_join_rel_hook = NULL;
 
 static void make_rels_by_clause_joins(PlannerInfo *root,
 									  RelOptInfo *old_rel,
@@ -702,6 +703,23 @@ init_dummy_sjinfo(SpecialJoinInfo *sjinfo, Relids left_relids,
  */
 RelOptInfo *
 make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)
+{
+	RelOptInfo *result;
+
+	if (make_join_rel_hook)
+	{
+		result = (*make_join_rel_hook) (root, rel1, rel2);
+	}
+	else
+	{
+		result = standard_make_join_rel(root, rel1, rel2);
+	}
+	return result;
+}
+
+
+RelOptInfo *
+standard_make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)
 {
 	Relids		joinrelids;
 	SpecialJoinInfo *sjinfo;
diff --git a/src/backend/optimizer/plan/planmain.c b/src/backend/optimizer/plan/planmain.c
index e17d31a..66ac105 100644
--- a/src/backend/optimizer/plan/planmain.c
+++ b/src/backend/optimizer/plan/planmain.c
@@ -30,6 +30,8 @@
 #include "optimizer/planmain.h"
 
 
+prepare_make_one_rel_hook_type prepare_make_one_rel_hook = NULL;
+
 /*
  * query_planner
  *	  Generate a path (that is, a simplified plan) for a basic query,
@@ -274,6 +276,9 @@ query_planner(PlannerInfo *root,
 	 */
 	distribute_row_identity_vars(root);
 
+	if (prepare_make_one_rel_hook)
+		prepare_make_one_rel_hook(root, joinlist);
+
 	/*
 	 * Ready to do the primary planning.
 	 */
diff --git a/src/backend/optimizer/util/pathnode.c b/src/backend/optimizer/util/pathnode.c
index c42742d..82e8c28 100644
--- a/src/backend/optimizer/util/pathnode.c
+++ b/src/backend/optimizer/util/pathnode.c
@@ -39,6 +39,9 @@ typedef enum
 	COSTS_DIFFERENT,			/* neither path dominates the other on cost */
 } PathCostComparison;
 
+add_path_hook_type add_path_hook = NULL;
+add_partial_path_hook_type add_partial_path_hook = NULL;
+
 /*
  * STD_FUZZ_FACTOR is the normal fuzz factor for compare_path_costs_fuzzily.
  * XXX is it worth making this user-controllable?  It provides a tradeoff
@@ -358,8 +361,26 @@ set_cheapest(RelOptInfo *parent_rel)
 	parent_rel->cheapest_parameterized_paths = parameterized_paths;
 }
 
+
 /*
  * add_path
+ * 	  Consider a potential implementation path for the specified parent rel,
+ * 	  and add it to the rel's pathlist if it is worthy of consideration.
+ *
+ * 	  The precise policy followed by add_path is determined by the add_path_hook.
+ * 	  The default policy is specified by standard_add_path.
+ */
+void
+add_path(RelOptInfo *parent_rel, Path *new_path)
+{
+	if (add_path_hook)
+		(*add_path_hook) (parent_rel, new_path);
+	else
+		standard_add_path(parent_rel, new_path);
+}
+
+/*
+ * standard_add_path
  *	  Consider a potential implementation path for the specified parent rel,
  *	  and add it to the rel's pathlist if it is worthy of consideration.
  *	  A path is worthy if it has a better sort order (better pathkeys) or
@@ -417,7 +438,7 @@ set_cheapest(RelOptInfo *parent_rel)
  * Returns nothing, but modifies parent_rel->pathlist.
  */
 void
-add_path(RelOptInfo *parent_rel, Path *new_path)
+standard_add_path(RelOptInfo *parent_rel, Path *new_path)
 {
 	bool		accept_new = true;	/* unless we find a superior old path */
 	int			insert_at = 0;	/* where to insert new item */
@@ -706,6 +727,26 @@ add_path_precheck(RelOptInfo *parent_rel,
 
 /*
  * add_partial_path
+ *    Similar to add_path, but for partial paths.
+ * 	  Consider a potential implementation path for the specified parent rel,
+ * 	  and add it to the rel's partial_pathlist if it is worthy of consideration.
+ *
+ * 	  The precise policy followed by add_partial_path is determined by the
+ *    add_partial_path_hook. The default policy is specified by
+ *    standard_add_partial_path.
+ */
+void
+add_partial_path(RelOptInfo *parent_rel, Path *new_path)
+{
+	if (add_partial_path_hook)
+		(*add_partial_path_hook) (parent_rel, new_path);
+	else
+		standard_add_partial_path(parent_rel, new_path);
+}
+
+
+/*
+ * standard_add_partial_path
  *	  Like add_path, our goal here is to consider whether a path is worthy
  *	  of being kept around, but the considerations here are a bit different.
  *	  A partial path is one which can be executed in any number of workers in
@@ -744,7 +785,7 @@ add_path_precheck(RelOptInfo *parent_rel,
  *	  referenced by partial BitmapHeapPaths.
  */
 void
-add_partial_path(RelOptInfo *parent_rel, Path *new_path)
+standard_add_partial_path(RelOptInfo *parent_rel, Path *new_path)
 {
 	bool		accept_new = true;	/* unless we find a superior old path */
 	int			insert_at = 0;	/* where to insert new item */
diff --git a/src/bin/initdb/initdb.c b/src/bin/initdb/initdb.c
index b050355..1ecebad 100644
--- a/src/bin/initdb/initdb.c
+++ b/src/bin/initdb/initdb.c
@@ -813,15 +813,6 @@ get_id(void)
 {
 	const char *username;
 
-#ifndef WIN32
-	if (geteuid() == 0)			/* 0 is root's uid */
-	{
-		pg_log_error("cannot be run as root");
-		pg_log_error_hint("Please log in (using, e.g., \"su\") as the (unprivileged) user that will own the server process.");
-		exit(1);
-	}
-#endif
-
 	username = get_user_name_or_exit(progname);
 
 	return pg_strdup(username);
diff --git a/src/bin/pg_ctl/pg_ctl.c b/src/bin/pg_ctl/pg_ctl.c
index ed97eb3..3258523 100644
--- a/src/bin/pg_ctl/pg_ctl.c
+++ b/src/bin/pg_ctl/pg_ctl.c
@@ -2238,21 +2238,6 @@ main(int argc, char **argv)
 		}
 	}
 
-	/*
-	 * Disallow running as root, to forestall any possible security holes.
-	 */
-#ifndef WIN32
-	if (geteuid() == 0)
-	{
-		write_stderr(_("%s: cannot be run as root\n"
-					   "Please log in (using, e.g., \"su\") as the "
-					   "(unprivileged) user that will\n"
-					   "own the server process.\n"),
-					 progname);
-		exit(1);
-	}
-#endif
-
 	env_wait = getenv("PGCTLTIMEOUT");
 	if (env_wait != NULL)
 		wait_seconds = atoi(env_wait);
diff --git a/src/bin/pg_resetwal/pg_resetwal.c b/src/bin/pg_resetwal/pg_resetwal.c
index e9dcb5a..1772cee 100644
--- a/src/bin/pg_resetwal/pg_resetwal.c
+++ b/src/bin/pg_resetwal/pg_resetwal.c
@@ -328,22 +328,6 @@ main(int argc, char *argv[])
 		exit(1);
 	}
 
-	/*
-	 * Don't allow pg_resetwal to be run as root, to avoid overwriting the
-	 * ownership of files in the data directory. We need only check for root
-	 * -- any other user won't have sufficient permissions to modify files in
-	 * the data directory.
-	 */
-#ifndef WIN32
-	if (geteuid() == 0)
-	{
-		pg_log_error("cannot be executed by \"root\"");
-		pg_log_error_hint("You must run %s as the PostgreSQL superuser.",
-						  progname);
-		exit(1);
-	}
-#endif
-
 	get_restricted_token();
 
 	/* Set mask based on PGDATA permissions */
diff --git a/src/bin/pg_rewind/pg_rewind.c b/src/bin/pg_rewind/pg_rewind.c
index 052c83b..2b7fb23 100644
--- a/src/bin/pg_rewind/pg_rewind.c
+++ b/src/bin/pg_rewind/pg_rewind.c
@@ -270,22 +270,6 @@ main(int argc, char **argv)
 		exit(1);
 	}
 
-	/*
-	 * Don't allow pg_rewind to be run as root, to avoid overwriting the
-	 * ownership of files in the data directory. We need only check for root
-	 * -- any other user won't have sufficient permissions to modify files in
-	 * the data directory.
-	 */
-#ifndef WIN32
-	if (geteuid() == 0)
-	{
-		pg_log_error("cannot be executed by \"root\"");
-		pg_log_error_hint("You must run %s as the PostgreSQL superuser.",
-						  progname);
-		exit(1);
-	}
-#endif
-
 	get_restricted_token();
 
 	/* Set mask based on PGDATA permissions */
diff --git a/src/include/commands/explain.h b/src/include/commands/explain.h
index 9b8b351..e390fb3 100644
--- a/src/include/commands/explain.h
+++ b/src/include/commands/explain.h
@@ -142,4 +142,14 @@ extern void ExplainCloseGroup(const char *objtype, const char *labelname,
 
 extern DestReceiver *CreateExplainSerializeDestReceiver(ExplainState *es);
 
+extern PGDLLIMPORT char *PLANNER_TYPE_UNSET;
+extern PGDLLIMPORT char *PLANNER_TYPE_CUSTOM;
+extern PGDLLIMPORT char *PLANNER_TYPE_DEFAULT;
+extern PGDLLIMPORT char *JOIN_ORDER_TYPE_CUSTOM;
+extern PGDLLIMPORT char *JOIN_ORDER_TYPE_GEQO;
+extern PGDLLIMPORT char *JOIN_ORDER_TYPE_STANDARD;
+
+extern PGDLLIMPORT char **current_planner_type;
+extern PGDLLIMPORT char **current_join_ordering_type;
+
 #endif							/* EXPLAIN_H */
diff --git a/src/include/optimizer/cost.h b/src/include/optimizer/cost.h
index b1c51a4..ee02165 100644
--- a/src/include/optimizer/cost.h
+++ b/src/include/optimizer/cost.h
@@ -72,6 +72,140 @@ extern PGDLLIMPORT bool enable_presorted_aggregate;
 extern PGDLLIMPORT bool enable_async_append;
 extern PGDLLIMPORT int constraint_exclusion;
 
+/* Hook for plugins to provide own cardinality estimates for base rels */
+typedef double (*set_baserel_size_estimates_hook_type) (PlannerInfo *root, RelOptInfo *rel);
+extern PGDLLIMPORT set_baserel_size_estimates_hook_type set_baserel_size_estimates_hook;
+
+/* Hook for plugins to provide own cardinality estimates for join rels */
+typedef double (*set_joinrel_size_estimates_hook_type) (PlannerInfo *root, RelOptInfo *rel,
+														RelOptInfo *outer_rel, RelOptInfo *inner_rel,
+														SpecialJoinInfo *sjinfo, List *restrictlist);
+extern PGDLLIMPORT set_joinrel_size_estimates_hook_type set_joinrel_size_estimates_hook;
+
+
+/* Hooks for cost estimation functions */
+typedef void (*cost_seqscan_hook_type) (Path *path, PlannerInfo *root, RelOptInfo *baserel,
+										ParamPathInfo *param_info);
+extern PGDLLIMPORT cost_seqscan_hook_type cost_seqscan_hook;
+
+/* XXX: missing hook for cost_samplescan */
+
+typedef void (*cost_index_hook_type) (IndexPath *path, PlannerInfo *root,
+									  double loop_count, bool partial_path);
+extern PGDLLIMPORT cost_index_hook_type cost_index_hook;
+
+typedef void (*cost_bitmap_heap_scan_hook_type) (Path *path, PlannerInfo *root, RelOptInfo *baserel,
+												 ParamPathInfo *param_info,
+												 Path *bitmapqual, double loop_count);
+extern PGDLLIMPORT cost_bitmap_heap_scan_hook_type cost_bitmap_heap_scan_hook;
+
+typedef void (*cost_bitmap_and_node_hook_type) (BitmapAndPath *path, PlannerInfo *root);
+extern PGDLLIMPORT cost_bitmap_and_node_hook_type cost_bitmap_and_node_hook;
+typedef void (*cost_bitmap_or_node_hook_type) (BitmapOrPath *path, PlannerInfo *root);
+extern PGDLLIMPORT cost_bitmap_or_node_hook_type cost_bitmap_or_node_hook;
+
+/*
+ * XXX: missing hooks for
+ * cost_tidscan cost_tidrangescan cost_subqueryscan cost_functionscan cost_valuesscan cost_tablefuncscan
+ * cost_ctescan cost_namedtuplestorescan cost_resultscan cost_recursive_union
+ */
+
+typedef void (*cost_sort_hook_type) (Path *path, PlannerInfo *root,
+									 List *pathkeys, Cost input_cost, double tuples, int width,
+									 Cost comparison_cost, int sort_mem,
+									 double limit_tuples);
+extern PGDLLIMPORT cost_sort_hook_type cost_sort_hook;
+
+typedef void (*cost_incremental_sort_hook_type) (Path *path,
+												 PlannerInfo *root, List *pathkeys, int presorted_keys,
+												 Cost input_startup_cost, Cost input_total_cost,
+												 double input_tuples, int width, Cost comparison_cost, int sort_mem,
+												 double limit_tuples);
+extern PGDLLIMPORT cost_incremental_sort_hook_type cost_incremental_sort_hook;
+
+/* XXX: missing hook for cost_append cost_merge_append */
+
+typedef void (*cost_rescan_hook_type) (PlannerInfo *root, Path *path,
+									   Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern PGDLLIMPORT cost_rescan_hook_type cost_rescan_hook;
+typedef void (*cost_memoize_rescan_hook_type) (PlannerInfo *root, MemoizePath *mpath,
+											   Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern PGDLLIMPORT cost_memoize_rescan_hook_type cost_memoize_rescan_hook;
+typedef void (*cost_material_hook_type) (Path *path,
+										 Cost input_startup_cost, Cost input_total_cost,
+										 double tuples, int width);
+extern PGDLLIMPORT cost_material_hook_type cost_material_hook;
+
+typedef void (*cost_agg_hook_type) (Path *path, PlannerInfo *root,
+									AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
+									int numGroupCols, double numGroups,
+									List *quals,
+									Cost input_startup_cost, Cost input_total_cost,
+									double input_tuples, double input_width);
+extern PGDLLIMPORT cost_agg_hook_type cost_agg_hook;
+
+typedef void (*cost_windowagg_hook_type) (Path *path, PlannerInfo *root,
+										  List *windowFuncs, WindowClause *winclause,
+										  Cost input_startup_cost, Cost input_total_cost,
+										  double input_tuples);
+extern PGDLLIMPORT cost_windowagg_hook_type cost_windowagg_hook;
+
+typedef void (*cost_group_hook_type) (Path *path, PlannerInfo *root,
+									  int numGroupCols, double numGroups,
+									  List *quals,
+									  Cost input_startup_cost, Cost input_total_cost,
+									  double input_tuples);
+extern PGDLLIMPORT cost_group_hook_type cost_group_hook;
+
+typedef void (*initial_cost_nestloop_hook_type) (PlannerInfo *root,
+												 JoinCostWorkspace *workspace,
+												 JoinType jointype,
+												 Path *outer_path, Path *inner_path,
+												 JoinPathExtraData *extra);
+extern PGDLLIMPORT initial_cost_nestloop_hook_type initial_cost_nestloop_hook;
+typedef void (*final_cost_nestloop_hook_type) (PlannerInfo *root, NestPath *path,
+											   JoinCostWorkspace *workspace,
+											   JoinPathExtraData *extra);
+extern PGDLLIMPORT final_cost_nestloop_hook_type final_cost_nestloop_hook;
+
+typedef void (*initial_cost_mergejoin_hook_type) (PlannerInfo *root,
+												  JoinCostWorkspace *workspace,
+												  JoinType jointype,
+												  List *mergeclauses,
+												  Path *outer_path, Path *inner_path,
+												  List *outersortkeys, List *innersortkeys,
+												  JoinPathExtraData *extra);
+extern PGDLLIMPORT initial_cost_mergejoin_hook_type initial_cost_mergejoin_hook;
+typedef void (*final_cost_mergejoin_hook_type) (PlannerInfo *root, MergePath *path,
+												JoinCostWorkspace *workspace,
+												JoinPathExtraData *extra);
+extern PGDLLIMPORT final_cost_mergejoin_hook_type final_cost_mergejoin_hook;
+
+typedef void (*initial_cost_hashjoin_hook_type) (PlannerInfo *root,
+												 JoinCostWorkspace *workspace,
+												 JoinType jointype,
+												 List *hashclauses,
+												 Path *outer_path, Path *inner_path,
+												 JoinPathExtraData *extra,
+												 bool parallel_hash);
+extern PGDLLIMPORT initial_cost_hashjoin_hook_type initial_cost_hashjoin_hook;
+typedef void (*final_cost_hashjoin_hook_type) (PlannerInfo *root, HashPath *path,
+											   JoinCostWorkspace *workspace,
+											   JoinPathExtraData *extra);
+extern PGDLLIMPORT final_cost_hashjoin_hook_type final_cost_hashjoin_hook;
+
+typedef void (*cost_gather_hook_type) (GatherPath *path, PlannerInfo *root,
+									   RelOptInfo *rel, ParamPathInfo *param_info, double *rows);
+extern PGDLLIMPORT cost_gather_hook_type cost_gather_hook;
+typedef void (*cost_gather_merge_hook_type) (GatherMergePath *path, PlannerInfo *root,
+											 RelOptInfo *rel, ParamPathInfo *param_info,
+											 Cost input_startup_cost, Cost input_total_cost,
+											 double *rows);
+extern PGDLLIMPORT cost_gather_merge_hook_type cost_gather_merge_hook;
+
+/* XXX: missing for cost_subplan*/
+
+/* Prototypes for cost estimation functions */
 extern double index_pages_fetched(double tuples_fetched, BlockNumber pages,
 								  double index_pages, PlannerInfo *root);
 extern void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
@@ -124,6 +258,10 @@ extern void cost_merge_append(Path *path, PlannerInfo *root,
 extern void cost_material(Path *path,
 						  Cost input_startup_cost, Cost input_total_cost,
 						  double tuples, int width);
+extern void cost_rescan(PlannerInfo *root, Path *path,
+						Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern void cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
+								Cost *rescan_startup_cost, Cost *rescan_total_cost);
 extern void cost_agg(Path *path, PlannerInfo *root,
 					 AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
 					 int numGroupCols, double numGroups,
@@ -213,4 +351,87 @@ extern double compute_bitmap_pages(PlannerInfo *root, RelOptInfo *baserel,
 								   Path *bitmapqual, double loop_count,
 								   Cost *cost_p, double *tuples_p);
 
+/* Prototypes of default cost estimation functions */
+extern void standard_cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+								  ParamPathInfo *param_info);
+extern void standard_cost_index(IndexPath *path, PlannerInfo *root,
+								double loop_count, bool partial_path);
+extern void standard_cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+										   ParamPathInfo *param_info,
+										   Path *bitmapqual, double loop_count);
+extern void standard_cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root);
+extern void standard_cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root);
+extern void standard_cost_sort(Path *path, PlannerInfo *root,
+							   List *pathkeys, Cost input_cost, double tuples, int width,
+							   Cost comparison_cost, int sort_mem,
+							   double limit_tuples);
+extern void standard_cost_incremental_sort(Path *path,
+										   PlannerInfo *root, List *pathkeys, int presorted_keys,
+										   Cost input_startup_cost, Cost input_total_cost,
+										   double input_tuples, int width, Cost comparison_cost, int sort_mem,
+										   double limit_tuples);
+extern void standard_cost_rescan(PlannerInfo *root, Path *path,
+								 Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern void standard_cost_memoize_rescan(PlannerInfo *root, MemoizePath *mpath,
+										 Cost *rescan_startup_cost, Cost *rescan_total_cost);
+extern void standard_cost_material(Path *path,
+								   Cost input_startup_cost, Cost input_total_cost,
+								   double tuples, int width);
+extern void standard_cost_agg(Path *path, PlannerInfo *root,
+							  AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
+							  int numGroupCols, double numGroups,
+							  List *quals,
+							  Cost input_startup_cost, Cost input_total_cost,
+							  double input_tuples, double input_width);
+extern void standard_cost_windowagg(Path *path, PlannerInfo *root,
+									List *windowFuncs, WindowClause *winclause,
+									Cost input_startup_cost, Cost input_total_cost,
+									double input_tuples);
+extern void standard_cost_group(Path *path, PlannerInfo *root,
+								int numGroupCols, double numGroups,
+								List *quals,
+								Cost input_startup_cost, Cost input_total_cost,
+								double input_tuples);
+extern void standard_initial_cost_nestloop(PlannerInfo *root,
+										   JoinCostWorkspace *workspace,
+										   JoinType jointype,
+										   Path *outer_path, Path *inner_path,
+										   JoinPathExtraData *extra);
+extern void standard_final_cost_nestloop(PlannerInfo *root, NestPath *path,
+										 JoinCostWorkspace *workspace,
+										 JoinPathExtraData *extra);
+extern void standard_initial_cost_mergejoin(PlannerInfo *root,
+											JoinCostWorkspace *workspace,
+											JoinType jointype,
+											List *mergeclauses,
+											Path *outer_path, Path *inner_path,
+											List *outersortkeys, List *innersortkeys,
+											JoinPathExtraData *extra);
+extern void standard_final_cost_mergejoin(PlannerInfo *root, MergePath *path,
+										  JoinCostWorkspace *workspace,
+										  JoinPathExtraData *extra);
+extern void standard_initial_cost_hashjoin(PlannerInfo *root,
+										   JoinCostWorkspace *workspace,
+										   JoinType jointype,
+										   List *hashclauses,
+										   Path *outer_path, Path *inner_path,
+										   JoinPathExtraData *extra,
+										   bool parallel_hash);
+extern void standard_final_cost_hashjoin(PlannerInfo *root, HashPath *path,
+										 JoinCostWorkspace *workspace,
+										 JoinPathExtraData *extra);
+extern void standard_cost_gather(GatherPath *path, PlannerInfo *root,
+								 RelOptInfo *rel, ParamPathInfo *param_info, double *rows);
+extern void standard_cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
+									   RelOptInfo *rel, ParamPathInfo *param_info,
+									   Cost input_startup_cost, Cost input_total_cost,
+									   double *rows);
+
+extern double standard_set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel);
+extern double standard_set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+												  RelOptInfo *outer_rel,
+												  RelOptInfo *inner_rel,
+												  SpecialJoinInfo *sjinfo,
+												  List *restrictlist);
+
 #endif							/* COST_H */
diff --git a/src/include/optimizer/pathnode.h b/src/include/optimizer/pathnode.h
index 112e7c2..6792aaa 100644
--- a/src/include/optimizer/pathnode.h
+++ b/src/include/optimizer/pathnode.h
@@ -18,6 +18,12 @@
 #include "nodes/pathnodes.h"
 
 
+typedef void (*add_path_hook_type) (RelOptInfo *parent_rel, Path *new_path);
+extern add_path_hook_type add_path_hook;
+
+typedef void (*add_partial_path_hook_type) (RelOptInfo *parent_rel, Path *new_path);
+extern add_partial_path_hook_type add_partial_path_hook;
+
 /*
  * prototypes for pathnode.c
  */
@@ -27,10 +33,12 @@ extern int	compare_fractional_path_costs(Path *path1, Path *path2,
 										  double fraction);
 extern void set_cheapest(RelOptInfo *parent_rel);
 extern void add_path(RelOptInfo *parent_rel, Path *new_path);
+extern void standard_add_path(RelOptInfo *parent_rel, Path *new_path);
 extern bool add_path_precheck(RelOptInfo *parent_rel,
 							  Cost startup_cost, Cost total_cost,
 							  List *pathkeys, Relids required_outer);
 extern void add_partial_path(RelOptInfo *parent_rel, Path *new_path);
+extern void standard_add_partial_path(RelOptInfo *parent_rel, Path *new_path);
 extern bool add_partial_path_precheck(RelOptInfo *parent_rel,
 									  Cost total_cost, List *pathkeys);
 
diff --git a/src/include/optimizer/paths.h b/src/include/optimizer/paths.h
index 5e88c02..0455983 100644
--- a/src/include/optimizer/paths.h
+++ b/src/include/optimizer/paths.h
@@ -48,6 +48,9 @@ typedef RelOptInfo *(*join_search_hook_type) (PlannerInfo *root,
 											  List *initial_rels);
 extern PGDLLIMPORT join_search_hook_type join_search_hook;
 
+typedef RelOptInfo *(*make_join_rel_hook_type) (PlannerInfo *root,
+												RelOptInfo *rel1, RelOptInfo *rel2);
+extern PGDLLIMPORT make_join_rel_hook_type make_join_rel_hook;
 
 extern RelOptInfo *make_one_rel(PlannerInfo *root, List *joinlist);
 extern RelOptInfo *standard_join_search(PlannerInfo *root, int levels_needed,
@@ -94,6 +97,41 @@ extern void add_paths_to_joinrel(PlannerInfo *root, RelOptInfo *joinrel,
 								 JoinType jointype, SpecialJoinInfo *sjinfo,
 								 List *restrictlist);
 
+extern Path *get_memoize_path(PlannerInfo *root,
+							  RelOptInfo *innerrel, RelOptInfo *outerrel,
+							  Path *inner_path, Path *outer_path,
+							  JoinType jointype, JoinPathExtraData *extra);
+
+extern void try_nestloop_path(PlannerInfo *root,
+							  RelOptInfo *joinrel,
+							  Path *outer_path, Path *inner_path,
+							  List *pathkeys,
+							  JoinType jointype, JoinPathExtraData *extra);
+
+extern void consider_parallel_nestloop(PlannerInfo *root, RelOptInfo *joinrel,
+									   RelOptInfo *outerrel, RelOptInfo *innerrel,
+									   JoinType jointype, JoinPathExtraData *extra);
+
+extern void sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+								 RelOptInfo *outerrel, RelOptInfo *innerrel,
+								 JoinType jointype, JoinPathExtraData *extra);
+
+extern void generate_mergejoin_paths(PlannerInfo *root, RelOptInfo *joinrel,
+									 RelOptInfo *innerrel, Path *outerpath,
+									 JoinType jointype, JoinPathExtraData *extra,
+									 bool useallclauses, Path *inner_cheapest_total,
+									 List *merge_pathkeys, bool is_partial);
+
+extern void consider_parallel_mergejoin(PlannerInfo *root, RelOptInfo *joinrel,
+										RelOptInfo *outerrel, RelOptInfo *innerrel,
+										JoinType jointype, JoinPathExtraData *extra,
+										Path *inner_cheapest_total);
+
+extern void hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel,
+								 RelOptInfo *outerrel, RelOptInfo *innerrel,
+								 JoinType jointype, JoinPathExtraData *extra);
+
+
 /*
  * joinrels.c
  *	  routines to determine which relations to join
@@ -101,6 +139,8 @@ extern void add_paths_to_joinrel(PlannerInfo *root, RelOptInfo *joinrel,
 extern void join_search_one_level(PlannerInfo *root, int level);
 extern RelOptInfo *make_join_rel(PlannerInfo *root,
 								 RelOptInfo *rel1, RelOptInfo *rel2);
+extern RelOptInfo *standard_make_join_rel(PlannerInfo *root,
+										  RelOptInfo *rel1, RelOptInfo *rel2);
 extern Relids add_outer_joins_to_relids(PlannerInfo *root, Relids input_relids,
 										SpecialJoinInfo *sjinfo,
 										List **pushed_down_joins);
diff --git a/src/include/optimizer/planmain.h b/src/include/optimizer/planmain.h
index aafc173..948c178 100644
--- a/src/include/optimizer/planmain.h
+++ b/src/include/optimizer/planmain.h
@@ -24,6 +24,10 @@ extern PGDLLIMPORT double cursor_tuple_fraction;
 /* query_planner callback to compute query_pathkeys */
 typedef void (*query_pathkeys_callback) (PlannerInfo *root, void *extra);
 
+/* callback for optimizer plugins before make_one_rel is called, but after root is initialized */
+typedef void (*prepare_make_one_rel_hook_type) (PlannerInfo *root, List *joinlist);
+extern PGDLLIMPORT prepare_make_one_rel_hook_type prepare_make_one_rel_hook;
+
 /*
  * prototypes for plan/planmain.c
  */
